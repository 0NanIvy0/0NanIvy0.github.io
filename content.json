{"meta":{"title":"NanIvy","subtitle":null,"description":"淡淡无名，月下起舞。","author":"NanIvy","url":""},"pages":[{"title":"about","date":"2020-10-31T04:14:36.000Z","updated":"2021-07-14T05:50:53.793Z","comments":false,"path":"about/index.html","permalink":"/about/index.html","excerpt":"","text":"[ロリが好きなのNanIvy] 与&nbsp; NanIvy&nbsp; （ 菜菜子萌新 ） 对话中... bot_ui_ini()","keywords":"关于我"},{"title":"bangumi","date":"2020-12-10T13:32:48.000Z","updated":"2021-03-02T09:06:22.259Z","comments":false,"path":"bangumi/index.html","permalink":"/bangumi/index.html","excerpt":"","text":"","keywords":null},{"title":"comment","date":"2020-10-30T15:13:48.000Z","updated":"2021-07-12T08:02:54.847Z","comments":true,"path":"comment/index.html","permalink":"/comment/index.html","excerpt":"","text":"念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》","keywords":"留言板"},{"title":"donate","date":"2020-10-30T15:13:05.000Z","updated":"2020-11-01T12:21:18.625Z","comments":false,"path":"donate/index.html","permalink":"/donate/index.html","excerpt":"","text":"","keywords":"谢谢饲主了喵~"},{"title":"lab","date":"2012-10-31T06:47:59.000Z","updated":"2021-07-12T08:25:48.543Z","comments":false,"path":"lab/index.html","permalink":"/lab/index.html","excerpt":"","text":"NanIvyの实验室Sakura主题yyds 绝赞装修中~","keywords":"Lab实验室"},{"title":"client","date":"2018-12-20T15:13:35.000Z","updated":"2020-10-31T07:26:27.764Z","comments":false,"path":"client/index.html","permalink":"/client/index.html","excerpt":"","text":"直接下载 or 扫码下载：","keywords":"Android客户端"},{"title":"links","date":"2020-10-31T07:11:06.000Z","updated":"2021-07-12T07:48:59.936Z","comments":true,"path":"links/index.html","permalink":"/links/index.html","excerpt":"","text":"","keywords":"友人帐"},{"title":"music","date":"2020-10-31T05:14:28.000Z","updated":"2021-07-12T08:04:02.637Z","comments":false,"path":"music/index.html","permalink":"/music/index.html","excerpt":"","text":"","keywords":"喜欢的音乐"},{"title":"video","date":"2018-12-20T15:14:38.000Z","updated":"2020-10-31T07:57:00.590Z","comments":false,"path":"video/index.html","permalink":"/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '放送时间: 2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 番组计划 这里将是永远的回忆 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }","keywords":"B站"},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2020-03-16T10:41:30.000Z","comments":true,"path":"rss/index.html","permalink":"/rss/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-12-12T14:14:16.000Z","updated":"2020-03-16T10:41:30.000Z","comments":true,"path":"tags/index.html","permalink":"/tags/index.html","excerpt":"","text":""},{"title":"theme-sakura","date":"2020-10-31T06:53:25.000Z","updated":"2021-07-12T07:51:21.306Z","comments":false,"path":"theme-sakura/index.html","permalink":"/theme-sakura/index.html","excerpt":"","text":"Hexo主题Sakura修改自WordPress主题Sakura，感谢原作者Mashiro以及感谢hojun大佬的努力。","keywords":"Hexo 主题 Sakura 🌸"}],"posts":[{"title":"近期自我总结21.9","slug":"近期自我总结21.9","date":"2021-09-10T07:10:02.000Z","updated":"2021-09-12T14:03:17.238Z","comments":true,"path":"2021/09/10/近期自我总结21.9/","link":"","permalink":"/2021/09/10/近期自我总结21.9/","excerpt":"","text":"近期总结​ 陆陆续续从暑假开始摸完了前端基础的三件套HTML,CSS,JavaScript的基础学习，很多稍微新点的内容，以及一些内容的深入并没有进行。最近倒是发生了一堆事情，让我明白了，我又菜又爱玩。现在看下来，我对前端大概有了一个模糊的印象了。 ​ 不过步子大了扯到蛋，学习不能急躁，接下来的任务要明确规划好路线，少走弯路。（虽然自己都不知道自己走弯了没有）。不过想想两个卡哇伊的女儿们，以及未来想要更多的女儿，去挤挤，争取下吧。 下一步尽量让自己块扯到蛋（bushi）。 学业上：java 离散 数据结构 数据库 跟进学习；处女座般的强迫症，要全部一起好好的过啦！ 前端上：仿站： 小米商城*3 次 使用html+css+javascript 第一次：参考b站教学，做个大概，有个感觉，顺便复习哈之前的html与css，并巩固才学的JavaScript。 第二次：丢开教程，总结第一次的不足，尽量独立完成第二次的内容。 第三次：完全不联网，关闭代码补全。尝试独自完成 在此期间： 跟进css与html的新特性学习，即html5+css3+深入理解css. 未曾设想的道路下次一定freeCodeCamp （有空一定去涨涨见识！）咕咕咕.jpg 给我等着es6几个常用新特性（其他的有空再摸了） vue框架（尝试在这里拓展更多未曾设想的道路） JavaScript高级编程（慢慢摸吧） less、sass 这桃又大又甜找个实习 值得购买的DLC拓展包小程序 react框架 Node.js Git/webpack ATRI~时间流逝吧，你是多么的残酷 ，时间停止吧，你是多么的美丽。 既然还有时间，就应该挣扎到最后。 因为还留有可能性，所以未来比过去更有价值。 “地球，也包括我吗？”","categories":[{"name":"随想","slug":"随想","permalink":"/categories/随想/"}],"tags":[{"name":"悦读","slug":"悦读","permalink":"/tags/悦读/"},{"name":"随想","slug":"随想","permalink":"/tags/随想/"}],"keywords":[{"name":"随想","slug":"随想","permalink":"/categories/随想/"}]},{"title":"前端学习笔记——JavaScript基础","slug":"前端学习笔记——JavaScript基础","date":"2021-09-02T01:07:22.000Z","updated":"2021-09-12T14:01:36.412Z","comments":true,"path":"2021/09/02/前端学习笔记——JavaScript基础/","link":"","permalink":"/2021/09/02/前端学习笔记——JavaScript基础/","excerpt":"","text":"参考学习路线：https://zhuanlan.zhihu.com/p/324351537 对前端初恋的感觉——绿叶学习网：http://www.lvyestudy.com/ 常见内置对象字符串对象获取字符串长度：在JavaScript中，使用length属性来获取字符串的长度。 语法： 字符串名.length 如： str=“ahujdhiahfiuahgiuha” str.length即可获取长度 大小写转换：JavaScript中，toLowerCase()方法将大写字符串转化为小写字符串，toUpperCase()方法将小写字符串转化为大写字符串。 语法： 字符串名.toLowerCase() 字符串名.toUpperCase() 获取某个字符：在JavaScript中，harAt()方法来获取字符串中的某一个字符。 语法： 字符串名.charAt(x) 获取字符串中第x+1个字符。 截取字符串：在JavaScript中，substring()方法来截取字符串的某一部分。 语法： 字符串名.substring(start, end) start,end为数字，下标都是从0开始，如（n,x）就是截取第n+1到x+1的字符串。 同时 可以去掉end，，则会截取从start后的所有字符串。 替换字符串：在JavaScript中，replace()方法来用一个字符串替换另外一个字符串的某一部分。 语法： 字符串名.replace(原字符串, 替换字符串) 字符串名.replace(正则表达式, 替换字符串) 分割字符串：在JavaScript中，split()方法把一个字符串分割成一个数组，这个数组存放的是原来字符串的所有字符片段。有多少个片段，数组元素个数就是多少。 语法： 字符串名.split(&quot;分割符&quot;) 如： var str = &quot;HTML,CSS,JavaScript&quot;; var arr = str.split(&quot;,&quot;); document.write(&quot;数组第1个元素是：&quot; + arr[0] + &quot;&lt;br/&gt;&quot;); document.write(&quot;数组第2个元素是：&quot; + arr[1] + &quot;&lt;br/&gt;&quot;); document.write(&quot;数组第3个元素是：&quot; + arr[2]); ​ split(&quot; &quot;)和split(&quot;&quot;)是不一样的！前者两个引号之间是有空格，所以表示用空格作为分割符来分割。后者两个引号之间是没有空格，可以用来分割字符串每一个字符。 ​ split()方法有两个参数：第1个参数表示分割符；第2个参数表示获取分割之后截取的前n个元素。（不常用） 如：var arr = str.split(“~”, 3); bili~nico~ytb~youku~aqiyi 得到结果 bili，nico，ytb。 检索字符串位置：在JavaScript中，indexOf()方法来找出“某个指定字符串”在字符串中首次出现的下标位置，也可以使用lastIndexOf()来找出“某个指定字符串”在字符串中最后出现的下标位置。 语法： 字符串名.indexOf(指定字符串) 字符串名.lastIndexOf(指定字符串) 如果字符串中包含“指定字符串”，indexOf()就会返回指定字符串首次出现的下标，而lastIndexOf()就会返回指定字符串最后出现的下标；如果字符串中不包含“指定字符串”，indexOf()或lastIndexOf()就会返回-1。 数组对象数组的创建：在JavaScript中，new关键字来创建一个数组。创建数组，常见的有两种形式：一种是“完整形式”；另外一种是“简写形式”。 语法： var 数组名 = new Array(元素1, 元素2, ……, 元素n); //完整形式 var 数组名 = [元素1, 元素2, ……, 元素n]; //简写形式 调用 arr[2] 同c语言。 获取数组长度：在JavaScript中，length属性来获取数组的长度。 语法： 数组名.length arr.length 数组有几个元素，长度就为多少。 截取数组部分：在JavaScript中，slice()方法来获取数组的某一部分。slice，就是“切片”的意思。 语法： 数组名.slice(start, end); start，end为下标， 且[start,end） 添加数组元素：在数组开头添加元素：unshift()在JavaScript中，使用unshift()方法在数组开头添加新元素，并且可以得到一个新的数组（也就是原数组变了）。 语法： 数组名.unshift(新元素1, 新元素2, ……, 新元素n) 在数组结尾添加元素：push()在JavaScript中，使用push()方法在数组结尾添加新元素，并且可以得到一个新的数组（也就是原数组变了）。 语法： 数组名.push(新元素1, 新元素2, ……, 新元素n) 删除数组元素：删除数组中第一个元素：shift()在JavaScript中，使用shift()方法来删除数组中的第一个元素，并且可以得到一个新的数组（也就是原数组变了）。 语法： 数组名.shift() 删除数组最后一个元素：pop()在JavaScript中，使用pop()方法来删除数组的最后一个元素，并且可以得到一个新数组（也就是原数组变了）。 语法： 数组名.pop() 数组大小比较：在JavaScript中，我们可以使用sort()方法来对数组中所有元素进行大小比较，然后按从大到小或者从小到大进行排序。 语法： 数组名.sort(函数名) “函数名”是定义数组元素排序的函数的名字。 //定义一个升序函数 function up(a, b) { return a - b; } //定义一个降序函数 function down(a, b) { return b - a; } //定义数组 var arr = [3, 9, 1, 12, 50, 21]; arr.sort(up); document.write(&quot;升序：&quot; + arr.join(&quot;、&quot;) + &quot;&lt;br/&gt;&quot;); arr.sort(down); document.write(&quot;降序：&quot; + arr.join(&quot;、&quot;)); 数组颠倒顺序在JavaScript中，使用reverse()方法来实现数组中所有元素的反向排列，也就是颠倒数组元素的顺序。reverse，就是“反向”的意思。 语法： 数组名.reverse(); 将数组连接成字符串：在JavaScript中，使用join()方法来将数组中的所有元素连接成一个字符串。 语法： 数组名.join(&quot;连接符&quot;); 不写连接符的话，默认为英文的逗号：,。 时间对象语法： var 日期对象名 = new Date(); 创建一个日期对象，必须使用new关键字。其中Date对象的方法有很多，主要分为两大类：getXxx()和setXxx()。getXxx()用于获取时间，setXxx()用于设置时间。 用于获取时间的getXxx() 方法 说明 getFullYear() 获取年份，取值为4位数字 getMonth() 获取月份，取值为0（一月）到11（十二月）之间的整数 getDate() 获取日数，取值为1~31之间的整数 getHours() 获取小时数，取值为0~23之间的整数 getMinutes() 获取分钟数，取值为0~59之间的整数 getSeconds() 获取秒数，取值为0~59之间的整数 用于设置时间的setXxx() 方法 说明 setFullYear() 可以设置年、月、日 setMonth() 可以设置月、日 setDate() 可以设置日 setHours() 可以设置时、分、秒、毫秒 setMinutes() 可以设置分、秒、毫秒 setSeconds() 可以设置秒、毫秒 数学对象Math对象跟其他对象不一样，我们不需要使用new关键字来创造，而是直接使用它的属性和方法就行。 语法： Math.属性 Math.方法 Math对象的属性常见 属性 说明 对应的数学形式 PI 圆周率 π LN2 2的自然对数 ln(2) LN10 10的自然对数 ln(10) LOG2E 以2为底的e的对数 log2e LOG10E 以10为底的e的对数 log10e SQRT2 2的平方根 √2 SQRT1_2 2的平方根的倒数 1/√2 在实际开发中，所有角度都是以“弧度”为单位的，例如180°就应该写成Math.PI，而360°就应该写成Math.PI2，以此类推。对于角度，在实际开发中推荐这种写法：“**度数 \\ Math.PI/180**”，因为这种写法可以让我们一眼就能看出角度是多少，例如： 120*Math.PI/180 //120° 150*Math.PI/180 //150° document.write(&quot;圆周率为：&quot; + Math.PI); Math对象的方法常见 方法 说明 max(a,b,…,n) 返回一组数中的最大值 min(a,b,…,n) 返回一组数中的最小值 sin(x) 正弦 cos(x) 余弦 tan(x) 正切 asin(x) 反正弦 acos(x) 反余弦 atan(x) 反正切 atan2(y, x) 反正切（注意y、x顺序） floor(x) 向下取整 ceil(x) 向上取整 random() 生成随机数 不常用 方法 说明 abs(x) 返回x的绝对值 sqrt(x) 返回x的平方根 log(x) 返回x的自然对数（底为e） pow(x,y) 返回x的y次幂 exp(x) 返回e的指数 生成随机数 random（）（1）Math.random()*m表示生成0~m之间的随机数，例如“Math.random()*10”表示生成0-10之间的随机数。 （2）Math.random()*m+n表示生成n~m+n之间的随机数，例如“Math.random()*10+8”表示生成8-18之间的随机数。 （3）Math.random()*m-n表示生成-n~m-n之间的随机数，例如“Math.random()*10-8”表示生成-8-2之间的随机数。 （4）Math.random()*m-m表示生成-m~0之间的随机数，例如“Math.random()*10-10”表示生成-10-0之间的随机数。 特别注意一下，这里的0~1是只包含0不包含1的，也就是[0, 1)。 tips：下面也是。 随机数生成某个范围内的“整数”对于Math.random()5来说，由于floor()是向下取整，因此Math.floor(Math.random()5)生成的是0~4之间的随机整数。如果你想生成0~5之间的随机整数，应该写成： Math.floor(Math.random()*(5+1)) 也就是说，如果你想生成0到m之间的随机整数，应该这样写： Math.floor(Math.random()*(m+1)) 如果你想生成1到m之间的随机整数（包括1和m），应该这样写： Math.floor(Math.random()*m)+1 如果你想生成n到m之间的随机整数（包括n和m），应该这样写： Math.floor(Math.random()*(m-n+1))+n 上面是用floor()来生成我们想要的随机整数，当然我们也可以使用ceil()来实现。只不过呢，我们只需要掌握2个方法中的任意一个就可以了。 DOMJavaScriptの三种常见节点类型（1）元素节点 （2）属性节点 （3）文本节点 不同结点的nodeType的值： 节点类型 nodeType值 元素节点 1 属性节点 2 文本节点 3 获取元素——元素节点 （1）getElementById() （2）getElementsByTagName() （3）getElementsByClassName() （4）querySelector()和querySelectorAll() （5）getElementsByName() （6）document.title和document.body getElementById（）get element by id 类css的id选择器 不加# 下面同理 语法： document.getElementById(&quot;id名&quot;) 示例： window.onload = function () { var oDiv = document.getElementById(&quot;div1&quot;); oDiv.style.color = &quot;red&quot;; } 此外，getElementById()获取的是一个DOM对象，在给变量命名的时候，习惯性地以英文“o”开头，以便跟其他变量区分开来，一眼就看出来这是一个DOM对象。 getElementsByTagName()get elements by tag name 注意 element这次加了s 复数，类似css元素选择器 语法： document. getElementsByTagName(&quot;标签名&quot;) window.onload = function () { var oUl = document.getElementById(&quot;list&quot;); var oLi = oUl.getElementsByTagName(&quot;li&quot;); oLi[2].style.color = &quot;red&quot;; } 获取id为list的ul中的第li，并使第三个li元素文字变红色。（伪数组，只能使用下标形式和length属性。不能使用push（）等，即添加一个末尾，并返回长度。） &lt;script&gt; window.onload = function () { var arr = [&quot;HTML&quot;, &quot;CSS&quot;, &quot;JavaScript&quot;, &quot;jQuery&quot;, &quot;Vue.js&quot;]; var oUl = document.getElementById(&quot;list&quot;); var oLi = document.getElementsByTagName(&quot;li&quot;); for (var i = 0; i &lt; oLi.length; i++) { oLi[i].innerHTML = arr[i]; oLi[i].style.color = &quot;red&quot;; } } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;ul id=&quot;list&quot;&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; 这样，获取了一个伪数组，调用的时候需要加上下标。 var oLi = oUl.getElementsByTagName(“li”); oLi[2].style.color = “red”; 但如果在获取元素的时候就指定好下标，就能直接使用指定的dom对象。 var occ = oUl.getElementsByTagName(“li”)[1]; oUl.removeChild(occ); getElementsByClassName()get element by classname 同理，注意s复数 类css的类选择器 语法： document. getElementsByClassName(&quot;类名&quot;) window.onload = function () { var oLi = document.getElementsByClassName(&quot;select&quot;); oLi[0].style.color = &quot;red&quot;; } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;ul id=&quot;list&quot;&gt; &lt;li&gt;HTML&lt;/li&gt; &lt;li&gt;CSS&lt;/li&gt; &lt;li class=&quot;select&quot;&gt;JavaScript&lt;/li&gt; &lt;li class=&quot;select&quot;&gt;jQuery&lt;/li&gt; &lt;li class=&quot;select&quot;&gt;Vue.js&lt;/li&gt; getElementsByClassName()获取的也是一个“类数组”。如果我们想得到某一个元素，也是使用数组下标的形式获取的，这一点跟getElementsByTagName()很相似。 querySelector()和querySelectorAll()JavaScript新增了querySelector()和querySelectorAll()两个方法，使得我们可以使用CSS选择器的语法来获取所需要的元素。 语法： document.querySelector(&quot;选择器&quot;); document.querySelectorAll(&quot;选择器&quot;); 说明： querySelector()表示选取满足选择条件的第1个元素，querySelectorAll()表示选取满足条件的所有元素。这两个方法都是非常简单的，它们的写法跟CSS选择器的写法是完全一样的。 document.querySelector(&quot;#main&quot;) document.querySelector(&quot;#list li:nth-child(1)&quot;) document.querySelectorAll(&quot;.list li&quot;) document.querySelectorAll(&quot;input:checkbox&quot;) 对于id选择器来说，由于页面只有一个元素，建议大家用getElementById()，而不是用querySelector()或querySelectorAll()这两个。因为getElementById()方法效率更高，性能也更快。 document.querySelector(“#list li:nth-child(3)”)表示选取id为list的元素下的第3个元素，nth-child(n)属于CSS3的选择器。 也可以使用document.querySelectorAll(“#list li:nth-child(3)”)[0]来实现，两者效果是一样的。特别注意一点，querySelectorAll()方法得到的是一个类数组，即使你获取的只有一个元素，也必须使用下标[0]才可以正确获取。 getElementsByName()对于表单元素来说，它有一个一般元素都没有的name属性。如果想要通过name属性来获取表单元素，我们可以使用getElementsByName()方法来实现。 语法： document.getElementsByName(&quot;name名&quot;) 说明： getElementsByName()获取的也是一个类数组，如果想要准确得到某一个元素，可以使用数组下标形式来获取。 getElementsByName()只用于表单元素，一般只用于单选按钮和复选框。 ​ document.title和document.body由于一个页面只有一个title元素和一个body元素，因此对于这两个元素的选取，JavaScript专门为我们提供了两个非常方便的方法：document.title和document.body。 &lt;script&gt; window.onload = function () { document.title = &quot;梦想是什么？&quot;; document.body.innerHTML = &quot;&lt;strong style=&#39;color:red&#39;&gt;梦想就是一种让你感到坚持就是幸福的东西。&lt;/strong&gt;&quot;; } &lt;/script&gt; 创建元素语法： var e1 = document.createElement(&quot;元素名&quot;); //创建元素节点 var txt = document.createTextNode(&quot;文本内容&quot;); //创建文本节点 e1.appendChild(txt); //把文本节点插入元素节点中 e2.appendChild(e1); //把组装好的元素插入已存在的元素中 示例 创建无属性的元素 window.onload = function () { var oDiv = document.getElementById(&quot;xibao&quot;); var oEm = document.createElement(&quot;em&quot;); var oTxt = document.createTextNode(&quot;灵魂潮汐&quot;); oEm.appendChild(oTxt); oDiv.appendChild(oEm); } &lt;div id=&quot;xibao&quot;&gt;&lt;/div&gt; 示例 创建带属性的元素window.onload = function () { var oPic = document.createElement(&quot;img&quot;); oPic.src = &quot;xxxxxxx.xxx.webp&quot;; oPic.style.border = &quot;10px solid pink&quot;; oPic.className = &quot;pic&quot;; document.body.appendChild(oPic); } 在操作动态DOM时，设置元素class用的是className而不是class，JavaScript有很多关键字和保留字，其中class已经作为保留字。 示例 创建动态表格：&lt;script&gt; window.onload = function () { //动态创建表格 var oTable = document.createElement(&quot;table&quot;); for (var i = 0; i &lt; 3; i++) { var oTr = document.createElement(&quot;tr&quot;); for (var j = 0; j &lt; 3; j++) { var oTd = document.createElement(&quot;td&quot;); var oTxt = document.createTextNode(i+&quot;,&quot;+j); oTd.appendChild(oTxt); oTr.appendChild(oTd); } oTable.appendChild(oTr); } //添加到body中去 document.body.appendChild(oTable); } &lt;/script&gt; 插入元素appendChild()把一个新元素插入到父元素的内部子元素的 末尾 。 语法： A.appendChild(B); A表示父元素，B表示动态创建好的新元素。 insertBefore()使用insertBefore()方法将一个新元素插入到父元素中的某一个子元素“之前”。 语法： A.insertBefore(B,ref); 说明： A表示父元素，B表示新子元素。ref表示指定子元素，在这个元素之前插入新子元素。 删除元素removeChild()方法来删除父元素下的某个子元素。 语法： A.removeChild(B); oUl.removeChild(oUl.lastElementChild);表示删除ul中最后一个li元素，其中oUl.lastElementChild表示ul中的最后一个子元素。如果想要删除第一个子元素，可以使用以下代码来实现： oUl.removeChild(oUl.firstElementChild); 复制元素cloneNode()方法来实现复制元素。 语法： obj.cloneNode(bool) 如：document.body.appendChild(oUl.cloneNode(1)); 将oUl复制到body中； 说明： 参数obj表示被复制的元素，而参数bool是一个布尔值。 替换元素使用replaceChild()方法来实现替换元素。 语法： A.replaceChild(new,old); 说明： A表示父元素，new表示新子元素，old表示旧子元素。 DOM进阶HTML属性操作（对象属性）获取HTML属性值获取HTML元素的属性值，一般都是通过属性名，来找到该属性对应的值。 语法： obj.attr 说明： obj是元素名，它一个DOM对象。所谓的DOM对象，指的是getElementById()、getElementsByTagName()等方法获取到的元素节点。 attr是属性名，对于一个对象来说，当然是通过点运算符（.）来获取它的属性值。 tips：常用表单获取内容：单行文字框，复选框，下拉选项，单选的值 都是通过属性value来获取： sks.value diuren.id qq.style.border yyds.name 等等类似的写法。 设置HTML属性值设置HTML元素的属性值，同样也是通过属性名来设置的，非常简单。 语法： obj.attr = &quot;值&quot;; 说明： obj是元素名，它一个DOM对象，attr是属性名。 直接赋值就完事。 HTML属性操作（对象方法）getAttribute()使用getAttribute()方法来获取元素的某个属性的值。 语法： obj.getAttribute(&quot;attr&quot;) 说明： obj元素名，attr属性名。下面两种获取属性值的形式是等价的。 obj.getAttribute(&quot;attr&quot;) obj.attr 这两种方式都可以用来获取静态HTML的属性值以及动态DOM的属性值。 差别在于前者能够获取用户的自定义属性（css3内容，非元素自带属性）； setAttribute()使用setAttribute()方法来设置元素的某个属性的值。 语法： obj.setAttribute(&quot;attr&quot;,&quot;值&quot;) 说明： obj是元素名，attr是属性名。setAttribute()方法有两个参数：第1个参数是属性名；第2个参数是你要设置的属性值。下面两种设置属性值的形式是等价的： obj.setAttribute(&quot;attr&quot;,&quot;值&quot;) obj.attr = &quot;值&quot;; 两者差别同上，对于自定义元素的支持不同。 removeAttribute()使用removeAttribute()方法来删除元素的某个属性。 语法： obj.removeAttribute(&quot;attr&quot;) 说明： 想要删除元素的某个属性，我们只有removeAttribute()这一个方法。此时，使用之前“对象属性”操作那种方式就无法实现了，因为那种方式没有提供这样的方法，只能删除标签。 hasAttribute()使用hasAttribute()方法来判断元素是否含有某个属性。 语法： obj.hasAttribute(&quot;attr&quot;) 说明： hasAttribute()方法返回一个布尔值，如果包含该属性，则返回true。如果不包含该属性，则返回false。 直接使用removeAttribute()删除元素的属性是不太正确的，比较严谨的做法是先用hasAttribute()判断这个属性是否存在，如果存在，才去删除。 CSS属性操作获取CSS属性值使用getComputedStyle()方法来获取一个CSS属性的取值。（获取最终样式） 语法： getComputedStyle(obj).attr obj表示DOM对象，也就是通过getElementById()、getElementsByTagName()等方法获取的元素节点。 attr表示CSS属性名。 tips：这里的属性名使用的是“骆驼峰型”的CSS属性名。举个例子，font-size应该写成fontSize，border-bottom-width应该写成borderBottomWidth（有没有感觉像骆驼峰），以此类推。 getComputedStyle()方法其实有两种写法，以下两种是等价的。也就是说： getComputedStyle(obj).attr等价于 getComputedStyle(obj)[&quot;attr&quot;]。 getComputedStyle(oBox).backgroundColor getComputedStyle(oBox)[&quot;backgroundColor&quot;] 事实上，凡是对象的属性都有这两种写法，例如oBtn.id可以写成oBtn[&quot;id&quot;]，document.getElementById(&quot;btn&quot;)可以写成document[&quot;getElementById&quot;](&quot;btn&quot;)，以此类推。 我们获取的文本框value值其实是字符串，也就是说变量attr和val都是字符串来的。因此是不能使用obj.style.attr这种方式来设置CSS属性的，而必须使用obj.style[“attr”]这种方式。 设置CSS属性style对象使用style对象来设置一个CSS属性的值，其实就是在元素的style属性来添加样式，这个设置的是“行内样式”。 语法： obj.style.attr = &quot;值&quot;; 说明： obj表示DOM对象，attr表示CSS属性名，采用的同样是“骆驼峰”型。 obj.style.attr等价于obj.style[“attr”]，例如oDiv.style.width等价于oDiv.style[“width”]; cssText属性使用cssText属性来同时设置多个CSS属性，这是在元素的style属性来添加的。 语法： obj.style.cssText = &quot;值&quot;; 说明： obj表示DOM对象，cssText的值是一个字符串，例如： oDiv.style.cssText = &quot;width:100px;height:100px;border:1px solid gray;&quot;; 这个字符串中的属性名不再使用骆驼峰型写法，而是使用平常的CSS写法，例如background-color应该写成background-color，而不是backgroundColor。 使用cssText来设置CSS属性，最终也是在元素的style属性中添加的。 tips：实际开发的时候，如果想要为一个元素同时设置多个CSS属性，少使用cssText来实现，更倾向于使用操作HTML属性的方式给元素加上一个class属性值，从而把样式整体给元素添加上。 DOM遍历查找父元素在JavaScript中，我们可以使用parentNode属性来获得某个元素的父元素。 语法： obj.parentNode 说明： obj是一个DOM对象，指的是使用getElementById()、getElementsByTagName()等方法获取的元素。 查找子元素在JavaScript中，可以使用以下两组方式来获得父元素中的所有子元素或某个子元素。 （1）childNodes、firstChild、lastChild （2）children、firstElementChild、lastElementChild 其中，childNodes获取的是所有的子节点。注意，这个子节点是包括元素节点以及文本节点的（如：换行也算一个）。而children获取的是所有的元素节点，不包括文本节点。 使用oUl.removeChild(oUl.lastElementChild);一句代码就可以轻松搞定。此外，firstElementChild获取的是第一个子元素节点，lastElementChild获取的是最后一个子元素节点。如果我们想要获取任意一个子元素节点，可以使用children[i]的方式来实现。 查找兄弟元素在JavaScript中，我们可以使用以下2组方式来获得兄弟元素。 （1）previousSibling、nextSibling （2）previousElementSibling、nextElementSibling previousSibling查找前一个兄弟节点，nextSibling查找后一个兄弟节点。previousElementSibling查找前一个兄弟元素节点，nextElementSibling查找后一个兄弟元素节点。 同上 第一组可能会查到文字节点（一般是空白节点，如换行等），只希望操作元素，使用第二组。 innerHTML和innerText使用innerHTML属性很方便地获取和设置一个元素的“内部元素”，也可以使用innerText属性获取和设置一个元素的“内部文本”。 var oImg = document.createElement(&quot;img&quot;); oImg.className = &quot;pic&quot;; oImg.src = &quot;images/haizei.png&quot;; oImg.style.border = &quot;1px solid silver&quot;; document.body.appendChild(oImg); 使用inner方法： document.body.innerHTML = &#39;&lt;img class=&quot;pic&quot; src=&quot;images/haizei.png&quot; style=&quot;border:1px solid silver&quot;/&gt;&#39;; inner的获取： window.onload = function () { var oP = document.getElementById(&quot;content&quot;); document.getElementById(&quot;txt1&quot;).value = oP.innerHTML; document.getElementById(&quot;txt2&quot;).value = oP.innerText; } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;p id=&quot;content&quot;&gt;&lt;strong style=&quot;color:hotpink;&quot;&gt;绿叶学习网&lt;/strong&gt;&lt;/p&gt; innerHTML是：&lt;input id=&quot;txt1&quot; type=&quot;text&quot;&gt;&lt;br /&gt; 是&lt;strong style=&quot;color:hotpink;&quot;&gt;绿叶学习网&lt;/strong&gt; innerText是：&lt;input id=&quot;txt2&quot; type=&quot;text&quot;&gt; 是绿叶学习网 innerHTML获取的是元素内部所有的内容，而innerText获取的仅仅是文本内容。 事件事件调用方式①在script标签中调用在script标签中调用事件，指的是在&lt; script &gt;&lt; /script &gt;标签内部调用事件。 语法： obj.事件名 = function() { …… }; 说明： obj是一个DOM对象，指的是使用getElementById()、getElementsByTagName()等方法获取到的元素节点。 ②在元素中调用事件在元素中调用事件，指的是直接在HTML属性中来调用事件，这个属性又叫做“事件属性”。 如： &lt;script&gt; function alertMes() { alert(&quot;！&quot;); } &lt;/script&gt; &lt;input type=&quot;button&quot; onclick=&quot;alertMes()&quot; value=&quot;弹出&quot; /&gt; 等价于： &lt;input type=&quot;button&quot; onclick=&quot;alert(&#39;！&#39;)&quot; value=&quot;弹出&quot; /&gt; 事件调用鼠标事件常见鼠标事件 事件 说明 onclick 鼠标单击事件 onmouseover 鼠标移入事件 onmouseout 鼠标移出事件 onmousedown 鼠标按下事件 onmouseup 鼠标松开事件 onmousemove 鼠标移动事件 键盘事件常见键盘事件 （1）键盘按下：onkeydown （2）键盘松开：onkeyup 表单事件常用的表单事件 （1）onfocus和onblur （2）onselect （3）onchange 还有一个onsubmit事件。一般都是结合后端技术来使用。 onfocus和onblur：onfocus和onblur这两个事件往往都是配合一起使用的。例如用户准备在文本框中输入内容时，此时它会获得光标，就会触发onfocus事件。当文本框失去光标时，就会触发onblur事件。 并不是所有的HTML元素都有焦点事件，具有“获取焦点”和“失去焦点”特点的元素只有2种。 （1）表单元素（单选框、复选框、单行文本框、多行文本框、下拉列表） （2）超链接 判断一个元素是否具有焦点很简单，我们打开一个页面后按Tab键，能够选中的就是具有焦点特性的元素。在实际开发中，焦点事件（onfocus和onblur）一般用于单行文本框和多行文本框这两个，其他地方比较少用。 补充：focus()方法，可以让dom对象获得焦点，blur（）取消焦点，如： &lt;input type=&quot;button&quot; onclick=&quot;getfocus()&quot; value=&quot;获取焦点&quot;&gt; &lt;input type=&quot;button&quot; onclick=&quot;losefocus()&quot; value=&quot;移除焦点&quot;&gt; &lt;script&gt; function getfocus() { document.getElementById(&quot;myAnchor&quot;).focus(); } function losefocus() { document.getElementById(&quot;myAnchor&quot;).blur(); } ###### onselect在JavaScript中，当选中“单行文本框”或“多行文本框”中的内容时，就会触发onselect事件。 选中：指长按鼠标的时候，文字被选中，被蓝色围住。 补充：select（）方法，如下，当搜索框的文字被选择，会选取所有的文字。 var oSearch = document.getElementById(&quot;search&quot;); oSearch.onclick = function () { this.select(); }; onchangeonchange事件常用于“具有多个选项的表单元素”。 （1）单选框选择某一项时触发。 （2）复选框选择某一项时触发。 （3）下拉列表选择某一项时触发。 如果被勾选，则显示你的选择是xxx。同时，采用for循环给每个对象添加onchange事件。 var oFruit = document.getElementsByName(&quot;fruit&quot;); var oP = document.getElementById(&quot;content&quot;); for (var i = 0; i &lt; oFruit.length; i++) { oFruit[i].onchange = function () { if (this.checked) { oP.innerHTML = &quot;你选择的是：&quot; + this.value; } }; } 示例：复选框：全选/全不选 oSelectAll.onchange = function () { //如果选中，即this.checked返回true if (this.checked) { for (var i = 0; i &lt; oFruit.length; i++) { oFruit[i].checked = true; } } else { for (var i = 0; i &lt; oFruit.length; i++) { oFruit[i].checked = false; } } 示例：下拉菜单跳转网站：选择下拉列表的某一项时，就会触发onchange事件，然后就会在新的窗口打开对应的页面。 window.onload = function () { var oList = document.getElementById(&quot;list&quot;); oList.onchange = function () { var link = this.options[this.selectedIndex].value; window.open(link); }; } &lt;select id=&quot;list&quot;&gt; &lt;option value=&quot;http://wwww.baidu.com&quot;&gt;百度&lt;/option&gt; &lt;option value=&quot;http://www.sina.com.cn&quot;&gt;新浪&lt;/option&gt; &lt;option value=&quot;http://www.qq.com&quot;&gt;腾讯&lt;/option&gt; &lt;option value=&quot;http://www.sohu.com&quot;&gt;搜狐&lt;/option&gt; &lt;/select&gt; 注：对于select元素来说，我们可以使用obj.options[n]的方式来得到某一个列表项，这个列表项也是一个DOM对象。并且还可以使用obj.selectedIndex来获取你所选择的这个列表项的下标。这两个都是下拉列表所独有的也是经常用的方法。 编辑事件在JavaScript中，常用的编辑事件有3种。 oncopy onselectstart oncontextmenu oncopy在JavaScript中，我们可以使用oncopy事件来防止页面内容被复制。 语法： document.body.oncopy = function () { return false; } onselectstart在JavaScript中，我们可以使用onselectstart事件来防止页面内容被选取。 语法： document.body.onselectstart=function() { return false; } oncontextmenu在JavaScript中，我们可以使用oncontextmenu事件来禁止鼠标右键。 语法： document.oncontextmenu = function () { return false; } 页面事件onload在JavaScript中，onload表示文档加载完成后再执行的一个事件。 语法： window.onload = function(){ …… } 说明： 并不是所有情况都需要用到window.onload的，一般来说，只有在想要“获取页面中某一个元素”的时候才会用到。很重要。 浏览器从上到下解析到window.onload时，就会先不解析window.onload里面的代码，而是继续往下解析，直到把整个HTML文档解析完了之后才会回去执行window.onload里面的代码。 onunload当用户未载入文档时执行的Javascript代码，极其少用。 onbeforeunload在JavaScript中，onbeforeunload表示离开页面之前触发的一个事件。 语法： window.onbeforeunload = function(){ …… } 说明： 与window.onload相对的应该是window.onunload，不过一般情况下我们极少用到window.onunload，而更倾向于使用window.onbeforeunload。 onbeforeunload与onunloadOnunload，onbeforeunload都是在刷新或关闭时调用， 可以在&lt;script&gt;脚本中通过window.onunload来指定或者在&lt;body&gt;里指定。 区别在于onbeforeunload在onunload之前执行，它还可以阻止onunload的执行。 Onbeforeunload也是在页面刷新或关闭时调用，Onbeforeunload是正要去服务器读取新的页面时调用，此时还没开始读取；而onunload则已经从服务器上读到了需要加载的新的页面，在即将替换掉当前页面时调用。Onunload是无法阻止页面的更新和关闭的。而 Onbeforeunload 可以做到。 1、onbeforeunload事件： 说明：目前三大主流浏览器中firefox和IE都支持onbeforeunload事件,opera尚未支持。 用法： ·object.onbeforeunload = handler ·&lt;element onbeforeunload = “handler” … &gt;&lt;/element&gt; 描述： 事件触发的时候弹出一个有确定和取消的对话框，确定则离开页面，取消则继续待在本页。handler可以设一个返回值作为该对话框的显示文本。 触发于： ·关闭浏览器窗口 ·通过地址栏或收藏夹前往其他页面的时候 ·点击返回，前进，刷新，主页其中一个的时候 ·点击 一个前往其他页面的url连接的时候 ·调用以下任意一个事件的时候：click，document write，document open，document close，window close ，window navigate ，window NavigateAndFind,location replace,location reload,form submit. ·当用window open打开一个页面，并把本页的window的名字传给要打开的页面的时候。 ·重新赋予location.href的值的时候。 ·通过input type=”submit”按钮提交一个具有指定action的表单的时候。 可以用在以下元素： ·BODY, FRAMESET, window 平台支持： IE4+/Win, Mozilla 1.7a+, Netscape 7.2+, Firefox0.9+ 示例： &lt;html xmlns=”http://www.w3.org/1999/xhtml“&gt; &lt;head&gt; &lt;meta http-equiv=”Content-Type” content=”text/html; charset=gb2312″ /&gt; &lt;title&gt;onbeforeunload测试&lt;/title&gt; &lt;script&gt; function checkLeave(){ event.returnValue=”确定离开当前页面吗？”; } &lt;/script&gt; &lt;/head&gt; &lt;body onbeforeunload=”checkLeave()”&gt; &lt;/body&gt; &lt;/html&gt; 2、onunload事件 用法： ·object.onunload = handler ·&lt;element onunload = “handler”&gt;&lt;/element&gt; 描述： 当用户关闭一个页面时触发 onunload 事件。 触发于： ·关闭浏览器窗口 ·通过地址栏或收藏夹前往其他页面的时候 ·点击返回，前进，刷新，主页其中一个的时候 ·点击 一个前往其他页面的url连接的时候 ·调用以下任意一个事件的时候：click，document write，document open，document close，window close ，window navigate ，window NavigateAndFind,location replace,location reload,form submit. ·当用window open打开一个页面，并把本页的window的名字传给要打开的页面的时候。 ·重新赋予location.href的值的时候。 ·通过input type=”submit”按钮提交一个具有指定action的表单的时候。 示例： &lt;html xmlns=http://www.w3.org/1999/xhtml&gt; &lt;head&gt; &lt;meta http-equiv=”Content-Type” content=”text/html; charset=gb2312″ /&gt; &lt;title&gt;onunload测试&lt;/title&gt; &lt;script&gt; function checkLeave(){ alert(”欢迎下次再来！”); } &lt;/script&gt; &lt;/head&gt; &lt;body onunload=”checkLeave()”&gt; &lt;/body&gt; &lt;/html&gt; 分享： 事件监听想要给元素添加一个事件，其实我们有以下2种方式。 （1）事件处理器 （2）事件监听器 事件处理器在前面的学习中，如果想要给元素添加一个事件，我们都是通过操作HTML属性的方式来实现，这种方式其实也叫“事件处理器”，例如： oBtn.onclick = function(){……}; 事件监听器绑定事件所谓的“事件监听器”，指的是使用addEventListener()方法来为一个元素添加事件，又称之为“绑定事件”。 语法： obj.addEventListener(type , fn , false) 说明： obj是一个DOM对象，指的是使用getElementById()、getElementsByTagName()等方法获取到的元素节点。 type是一个字符串，指的是事件类型。例如单击事件用click，鼠标移入用mouseover等。注意，这个事件类型是不需要加上“on”前缀的。 fn是一个函数名，或者一个匿名函数。 false表示事件冒泡阶段调用。 例如： //fn是一个函数名 oBtn.addEventListener(&quot;click&quot;, alertMes, false); function alertMes() { alert(&quot;JavaScript&quot;); } //fn是一个匿名函数 oBtn.addEventListener(&quot;click&quot;, function () { alert(&quot;JavaScript&quot;); }, false); 上面这两段代码效果相同。 &lt;script&gt; window.onload = function () { var oBtn = document.getElementById(&quot;btn&quot;); oBtn.addEventListener(&quot;click&quot;, function () { alert(&quot;第1次&quot;); }, false); oBtn.addEventListener(&quot;click&quot;, function () { alert(&quot;第2次&quot;); }, false); oBtn.addEventListener(&quot;click&quot;, function () { alert(&quot;第3次&quot;); }, false); } &lt;/script&gt; 上面：使用事件监听器这种方式来为同一个元素添加多个相同的事件，而这一点是事件处理器做不到的。 一般情况下，如果想要为元素仅仅添加一个事件的话，下面两种方式其实是等价的。 obj.addEventListener(&quot;click&quot;, function () {……}, false); obj.onclick = function () {……}; 解绑事件在JavaScript中，可以使用removeEventListener()方法为元素解绑（或解除）某个事件。解绑事件与绑定事件是相反的操作。 语法： obj.removeEventListener(type , fn , false); 说明： obj是一个DOM对象，指的是使用getElementById()、getElementsByTagName()等方法获取到的元素节点。 type是一个字符串，指的是事件类型。例如，单击事件用click，鼠标移入用mouseover等。一定要注意，这里我们是不需要加上on前缀的。 对于removeEventListener()方法来说，fn必须是一个函数名，而不能是一个函数。 window.onload = function () { var oP = document.getElementById(&quot;content&quot;); var oBtn = document.getElementById(&quot;btn&quot;); //为p添加事件 oP.addEventListener(&quot;click&quot;, changeColor, false); //点击按钮后，为p解除事件 oBtn.addEventListener(&quot;click&quot;, function () { oP.removeEventListener(&quot;click&quot;, changeColor, false); }, false); function changeColor() { this.style.color = &quot;hotpink&quot;; } } 如果你想要使用removeEventListener()方法来解除一个事件，那么当初使用addEventListener()添加事件的时候，就一定要用定义函数的形式。 实际上，removeEventListener()只可以解除“事件监听器”添加的事件，它是不可以解除“事件处理器”添加的事件。如果想要解除“事件处理器”添加的事件，我们可以使用“obj.事件名 = null;”来实现，如： oP.onclick = changeColor; //点击按钮后，为p元素解除事件 oBtn.addEventListener(&quot;click&quot;, function () { oP.onclick = null; }, false); 解绑事件妙用法： 限制按钮只可以执行一次点击事件。实现思路很简单，在点击事件函数的最后解除事件就可以了。 oP.onclick = changeColor; //点击按钮后，为p元素解除事件 oBtn.addEventListener(&quot;click&quot;, function () { oP.onclick = null; }, false); DLC：onload多次使用的解决方案在实际开发中，有可能会使用多次window.onload，但是会发现JavaScript只执行最后一次window.onload。为了解决这个问题，就可以使用addEventListener()来实现。在这个例子中，只需要将每一个window.onload改为以下代码即可： window.addEventListener(&quot;load&quot;,function(){……},false); 事实上，还有一种解决方法，那就是使用网上流传甚广的addLoadEvent()函数。addLoadEvent不是JavaScript内置函数，而是需要自己定义的。其中，addLoadEvent()函数代码如下： //装饰者模式 function addLoadEvent(func) { var oldonload = window.onload; if (typeof window.onload != &quot;function&quot;) { window.onload = func; }else { window.onload = function() { oldonload(); func(); } } } 然后我们只需要调用addLoadEvent()函数，就等于调用window.onload了。调用方法如下： addLoadEvent(function(){ …… }); event对象当一个事件发生的时候，这个事件有关的详细信息都会临时保存到一个指定的地方，这个地方就是event对象。 event对象常用属性如表所示 属性 说明 type 事件类型 keyCode 键码值 shiftKey 是否按下shift键 ctrlKey 是否按下Ctrl键 altKey 是否按下Alt键 type在JavaScript中，我们可以使用event对象的type属性来获取事件的类型。 oBtn.onclick = function (e) { alert(e.type); }; 实际上，每次调用一个事件的时候，JavaScript都会默认给这个事件函数加上一个隐藏的参数，这个参数就是event对象。一般来说，event对象是作为事件函数的第1个参数传入的 e仅仅是一个变量名，它存储的是一个event对象。也就是说，e可以换成其他名字，如ev、event、a等都可以， keyCode在JavaScript中，如果我们想要获取按下了键盘中的哪个键，可以使用event对象的keyCode属性来获取。 语法： event.keyCode 说明： event.keyCode返回的是一个数值，常用的按键及对应的键码如表所示。 按键 键码 W（上） 87 S（下） 83 A（左） 65 D（右） 68 ↑ 38 ↓ 40 ← 37 → 39 如果是shift、ctrl和alt键，我们不需要通过keyCode属性来获取，而是可以通过shiftKey、ctrlKey和altKey属性获取。 禁止按键： window.onload = function () { document.onkeydown = function (e) { if (e.shiftKey || e.altKey || e.ctrlKey) { alert(&quot;禁止使用shift、alt、ctrl键！&quot;) } } } e.keyCode返回的是一个数字，而e.shiftKey、e.ctrlKey、e.altKey返回的都是布尔值（true或false），注意一下两者的区别。 this在JavaScript中，this是非常复杂的。这里只记录this在事件操作中的使用情况进行介绍，而对于this在其他场合（如面向对象开发等）的使用，在JavaScript进阶部分再详细讲解。 在事件操作中，可以这样理解：哪个DOM对象（元素节点）调用了this所在的函数，那么this指向的就是哪个DOM对象。 window.onload = function () { var oDiv = document.getElementsByTagName(&quot;div&quot;)[0]; oDiv.onclick = function () { this.style.color = &quot;hotpink&quot;; } } var oDiv = document.getElementsByTagName(&quot;div&quot;)[0]; oDiv.onclick = changeColor; function changeColor() { this.style.color = &quot;hotpink&quot;; } 上面两个例子等效， 又如： var oDiv = document.getElementsByTagName(&quot;div&quot;)[0]; var oP = document.getElementsByTagName(&quot;p&quot;)[0]; oDiv.onclick = changeColor; oP.onclick = changeColor; function changeColor() { this.style.color = &quot;hotpink&quot;; } Window对象在JavaScript中，一个浏览器窗口就是一个window对象（这句话很重要）。 window下的子对象 子对象 说明 document 文档对象，用于操作页面元素 location 地址对象，用于操作URL地址 navigator 浏览器对象，用于获取浏览器版本信息 history 历史对象，用于操作浏览历史 screen 屏幕对象，用于操作屏幕宽度高度 window对象常用方法 方法 说明 alert() 提示对话框 confirm() 判断对话框 prompt() 输入对话框 open() 打开窗口 close() 关闭窗口 setTimeout() 开启“一次性”定时器 clearTimeout() 关闭“一次性”定时器 setInterval() 开启“重复性”定时器 clearInterval() 关闭“重复性”定时器 对于window对象来说，无论是它的属性，还是方法，都可以省略window前缀。例如window.alert()可以简写为alert()，window.open()可以简写为open()，甚至window.document.getElementById()可以简写为document.getElementById()，以此类推。 常用window对象： 窗口操作打开窗口在JavaScript中，可以使用window对象的open()方法来打开一个新窗口。 语法： window.open(url, target) 说明： window.open()可以直接简写为open()，不过我们一般都习惯加上window前缀。window.open()参数有很多，但是只有url和target这两个用得上。 url指的是新窗口的地址，如果url为空，则表示打开一个空白窗口。空白窗口很有用，我们可以使用document.write()往空白窗口输出文本，甚至输出一个HTML页面。 target表示打开方式，它的取值跟a标签中target属性的取值是一样的，常用取值有两个：_blank和_self。当target为“_blank（默认值）”，表示在新窗口打开；当target为“_self”时，表示在当前窗口打开。 oBtn.onclick = function () { window.open(&quot;nanivy.space&quot;); }; 往新打开的空白网页加入魔法： var oBtn = document.getElementById(&quot;btn&quot;); oBtn.onclick = function () { var opener = window.open(); opener.document.write(&quot;这是一个新窗口&quot;); opener.document.body.style.backgroundColor = &quot;lightskyblue&quot;; }; 示例2： oBtn.onclick = function () { opener = window.open(); var strHtml = &#39;&lt;!DOCTYPE html&gt;\\ &lt;html&gt;\\ &lt;head&gt;\\ &lt;title&gt;&lt;/title&gt;\\ &lt;/head&gt;\\ &lt;body&gt;\\ &lt;strong&gt;小心偷影子的人，他会带走你的心。&lt;/strong&gt;\\ &lt;/body&gt;\\ &lt;/html&gt;&#39;; opener.document.write(strHtml); }; opener是一个空白页面窗口，就可以使用document.write()方法来输出一个HTML文档了 window.open()就像函数调用一样，会返回（也就是return）一个值，这个值就是新窗口对应的window对象。也就是说，此时opener就是这个新窗口的window对象。只要我们获取到opener（也就是新窗口的window对象），就可以像平常那样随意操作页面的元素. 如果你打开的是同一个域名下的页面或空白窗口，就可以像上面那样操作新窗口的元素或样式。但是如果你打开的是另外一个域名下面的页面，是不允许操作新窗口的内容的，因为这个涉及跨越权限的问题。 关闭窗口在JavaScript中，我们可以使用window.close()来关闭一个新窗口。 语法： window.close() 说明： window.close()方法是没有参数的。 oBtn.onclick = function () { window.close(); }; 打开又关闭一个窗口 btnOpen.onclick = function () { opener = window.open(&quot;nanivy.space&quot;); }; btnClose.onclick = function () { opener.close(); } 此外还有其他窗口操作，待拓展 待补充：窗口最大化、最小化、控制窗口大小、移动窗口等对话框alert()在JavaScript中，alert()对话框一般仅仅用于提示文字。对于alert()，只需记住一点就行：在alert()中实现文本换行，用的是\\n。 语法： alert(&quot;提示文字&quot;) confirm()在JavaScript中，confirm()对话框不仅提示文字，还提供确认。 语法： confirm(&quot;提示文字&quot;) 说明： 如果用户点击【确定】按钮，则confirm()返回true。如果用户点击【取消】按钮，则confirm()返回false。 oBtn.onclick = function () { if (confirm(&quot;确定要跳转到绿叶首页吗？&quot;)) { window.location.href = &quot;http://www.lvyestudy.com&quot;; }else{ document.write(&quot;你取消了跳转&quot;); } }; prompt()在JavaScript中，prompt()对话框不仅提示文字，还返回一个字符串。 语法： prompt(&quot;提示文字&quot;) 总结 方法 说明 alert() 仅提示文字，没有返回值 confirm() 具有提示文字，返回“布尔值”（true或false） prompt() 具有提示文字，返回“字符串” 定时器setTimeout()和clearTimeout()在JavaScript中，我们可以使用setTimeout()方法来“一次性”地调用函数，并且可以使用clearTimeout()来取消执行setTimeout()。 语法： setTimeout(code, time); 说明： 参数code可以是一段代码，可以是一个函数，也可以是一个函数名。 参数time是时间，单位为毫秒，表示要过多长时间才执行code中的代码。 code是一段代码，2s； window.onload = function () { setTimeout(&#39;alert(&quot;欢迎来到xxx&quot;);&#39;, 2000); } code是一段函数 window.onload = function () { setTimeout(function () { alert(&quot;欢迎！&quot;); }, 2000); } code是函数名 window.onload = function () { setTimeout(alertMes, 2000); } function alertMes(){ alert(&quot;欢迎来到绿叶学习网&quot;); } 这里setTimeout()第一个参数是一个函数名，这个函数名是不需要加括号()的！下面两种写法是等价的： setTimeout(alertMes, 2000) setTimeout(&quot;alertMes()&quot;, 2000) clearTimeout的用法： window.onload = function () { //获取元素 var oBtn = document.getElementsByTagName(&quot;input&quot;); //timer存放定时器 var timer = null; oBtn[0].onclick = function () { timer = setTimeout(function () { alert(&quot;欢迎来到绿叶学习网&quot;); }, 2000); }; oBtn[1].onclick = function () { clearTimeout(timer); }; } setInterval()和clearInterval()在JavaScript中，可以使用setInterval()方法来“重复性”地调用函数，并且可以使用clearInterval()来取消执行setInterval()。 语法： setInterval(code, time); 说明： 参数code可以是一段代码，可以是一个函数，也可以是一个函数名。 参数time是时间，单位为毫秒，表示要过多长时间才执行code中的代码。 此外，setInterval()跟setTimeout()语法是一样的，唯一不同的是：setTimeout()只执行一次；而setInterval()可以重复执行无数次。对于setInterval()来说，下面3种方式都是正确的，这个跟setTimeout()一样： //方式1 setInterval(function(){…}, 2000) //方式2 setInterval(alertMes, 2000) //方式3 setInterval(&quot;alertMes()&quot;, 2000) 示例：倒计时器 var timer = null; //i用于计数 var i = 0; //“开始”按钮 oBtn[0].onclick = function () { //每次点击“开始”按钮，一开始就清除一次定时器，避免多次点击开始会产生bug。 clearInterval(timer); //每隔1秒切换一次背景颜色 timer = setInterval(function () { oDiv.style.backgroundColor = colors[i]; i++; i = i % colors.length; }, 1000); }; //“暂停”按钮 oBtn[1].onclick = function () { clearInterval(timer); }; clearInterval()用法同clearTimeout() 用变量来保存计时器，然后直接清除； clearInterval(timer); location对象在JavaScript中，可以使用window对象下的location子对象来操作当前窗口的URL。所谓URL，指的就是页面地址。对于location对象，只需要掌握以下3个属性（其他不用管），如表所示。 属性 说明 href 当前页面地址 search 当前页面地址“？”后面的内容 hash 当前页面地址“#”后面的内容 window.location.href在JavaScript中，我们可以使用location对象的href属性来获取或设置当前页面的地址。 语法： window.location.href 说明： window.location.href可以直接简写为location.href，不过我们一般都习惯加上window前缀。 var url = window.location.href; document.write(&quot;当前页面地址是：&quot; + url); 2s跳转 setTimeout(function () { window.location.href = &quot;http://www.lvyestudy.com&quot;; }, 2000); window.location.search在JavaScript中，我们可以使用location对象的search属性来获取和设置当前页面地址“?”后面的内容。 语法： window.location.search 例： document.write(window.location.search); window.location.hash在JavaScript中，可以使用location对象的hash属性来获取和设置当前页面地址井号（#）后面的内容。井号（#）一般用于锚点链接。 window.location.hash navigator对象在JavaScript中，可以使用window对象下的子对象navigator来获取浏览器的类型。 语法： window.navigator.userAgent if (window.navigator.userAgent.indexOf(&quot;MSIE&quot;) != -1) { alert(&quot;这是IE&quot;); }else if (window.navigator.userAgent.indexOf(&quot;Chrome&quot;) != -1) { alert(&quot;这是Chrome&quot;); }else if (window.navigator.userAgent.indexOf(&quot;Firefox&quot;) != -1) { alert(&quot;这是Firefox&quot;); } document对象常用 属性 说明 document.title 获取文档的title document.body 获取文档的body document.forms 获取所有form元素 document.images 获取所有img元素 document.links 获取所有a元素 document.cookie 文档的cookie document.URL 当前文档的URL document.referrer 返回使浏览者到达当前文档的URL （1）document.title和document.body之前获取元素已经了解。 （2）document.forms、document.images、document.links这3个分别等价于下面3个，所以一般用document.getElementsByTagName来获取就行了，不需要去记忆。 document.getElementsByTagName(&quot;form&quot;) document.getElementsByTagName(&quot;img&quot;) document.getElementsByTagName(&quot;a&quot;) （3）cookie一般结合后端技术操作中用得比较多，document.cookie单纯在前端中用得也不是非常多，我们简单看一下就行。 document.URL在JavaScript中，我们可以使用document对象的URL属性来获取当前页面的地址。 语法： document.URL &lt;script&gt; var url = document.URL; document.write(&quot;当前页面地址是：&quot; + url); &lt;/script&gt; document.URL和window.location.href都可以获取当前页面的URL，不过它们也有区别：document.URL只能获取不能设置；window.location.href既可以获取也可以设置。 document.referrer在JavaScript中，我们可以使用document对象的referrer属性来获取用户在访问当前页面之前所在页面的地址。例如我从页面A的某个链接进入页面B，如果在页面B中使用document.referrer，就可以获取到页面A的地址。 以建立两个页面，然后在第1个页面设置一个超链接指向第2个页面。当我们从第1个页面超链接进入第2个页面时，在第2个页面使用document.referrer就可以获取第1个页面的地址了。 document对象方法常用 方法 说明 document.getElementById() 通过id获取元素 document.getElementsByTagName() 通过标签名获取元素 document.getElementsByClassName() 通过class获取元素 document.getElementsByName() 通过name获取元素 document.querySelector() 通过选择器获取元素，只获取第1个 document.querySelectorAll() 通过选择器获取元素，获取所有 document.createElement() 创建元素节点 document.createTextNode() 创建文本节点 document.write() 输出内容 document.writeln() 输出内容并换行 document.write()在JavaScript中，可以使用document.write()输出内容。这个方法我们已经接触得够多了，这里不再赘述。 语法： document.write(&quot;内容&quot;); document.write(&#39;&lt;div style=&quot;color:hotpink;&quot;&gt;绿叶学习网&lt;/div&gt;&#39;); document.write()不仅可以输出文本，还可以输出标签。此外，document.write()都是往body标签内输出内容的。 document.writeln()不常用 writeln()方法跟write()方法相似，唯一区别是：writeln()方法会在输出内容后面多加上一个换行符\\n。 一般情况下，这两种方法在输出效果上是没有区别的，仅当在查看源码才看得出来区别，除非把内容输出到pre标签内。 语法： document.writeln(&quot;内容&quot;)","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"学习","slug":"学习","permalink":"/tags/学习/"},{"name":"JavaScript","slug":"JavaScript","permalink":"/tags/JavaScript/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"前端学习笔记——CSS基础","slug":"前端学习笔记——CSS基础","date":"2021-08-13T01:07:22.000Z","updated":"2021-09-12T14:05:35.175Z","comments":true,"path":"2021/08/13/前端学习笔记——CSS基础/","link":"","permalink":"/2021/08/13/前端学习笔记——CSS基础/","excerpt":"","text":"参考学习路线：https://zhuanlan.zhihu.com/p/324351537 对前端初恋的感觉——绿叶学习网：http://www.lvyestudy.com/ CSS基础补充DLC（持续跟进学习）display常见三种及特点display:block(块级元素)： 会独占一行 可设其宽、高、margin、padding属性 可容纳内联元素与其他块元素 display：inline(行内元素)： inline元素不会独占一行，多个相邻的行内元素会排列在同一行里，直到一行排列不下，才会新换一行，其宽度随元素的内容而变化。inline元素设置width,height属性无效。inline元素的margin和padding属性，水平方向的padding-left, padding-right, margin-left, margin-right都产生边距效果；但竖直方向的padding-top, padding-bottom, margin-top, margin-bottom不会产生边距效果。 display：inline-block（行内块元素）： 既可设置宽、高，又默认不换行 可设置vertical-align属性 在字体大小不为零的情况下，会产生元素间的空隙，可在父元素设置 font-size：0 ，也可用letter-spacing设为负值 去除此空隙 浮动是用display：inline-block(即 将块元素套在内联元素里，对内联元素进行浮动) inline-block对布局的理解：https://www.cnblogs.com/Ry-yuan/p/6848197.html 对CSS的认识CSS，指的是Cascading Style Sheet（层叠样式表），是用来控制网页外观的一门技术。我们知道，前端最核心的3个技术是：HTML、CSS、JavaScript，三者的关系： HTML用于控制网页的结构，CSS用于控制网页的外观，JavaScript控制的是网页的行为。 css引入方式在一个页面引入CSS，有以下3种方式。（忽略@import） （1）外部样式表 （2）内部样式表 （3）行内样式表 外部样式表外部样式表是最理想的CSS引入方式。在实际开发中，为了提升网站的性能速度和可维护性，一般都是使用外部样式表。所谓的外部样式表，指的是把CSS代码和HTML代码都单独放在不同文件中，然后在HTML文档中使用link标签来引用CSS样式表。 当样式需要被应用到多个页面时，外部样式表是最理想的选择。使用外部样式表，就可以通过更改一个CSS文件来改变整个网站的外观。 外部样式表在单独文件中定义，然后在HTML文件的标签对中使用link标签来引用： &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;文件路径&quot; /&gt; rel即relative的缩写，它的取值是固定的，即stylesheet，表示引入的是一个样式表文件（即CSS文件）。 type属性取值也是固定的，即&quot;text/css&quot;，表示这是标准的CSS。 href属性表示CSS文件的路径。 例子： &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;css/index.css&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; 外部样式表，使用link标签来引入，而link标签是放在head标签内。 内部样式表内部样式表，指的是把HTML代码和CSS代码放到同一个HTML文件中。其中，CSS代码放在style标签内，并且style标签是放在head标签内部的。 &lt;style type=&quot;text/css&quot;&gt; …… &lt;/style&gt; 如： &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;/&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; div{color:red;} &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;好好学习。&lt;/div&gt; &lt;div&gt;天天向上。&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 内部样式表，CSS样式必须在style标签内定义，style标签是放在head标签内的。 行内样式表行内样式表跟内部样式表类似，也是把HTML代码和CSS代码放到同一个HTML文件。但是两者有着本质的区别：内部样式表的CSS是在“style标签”内定义的，而行内样式表的CSS是在“标签的style属性”中定义的。 &lt;body&gt; &lt;div style=&quot;color:red;&quot;&gt;好好学习天天向上。&lt;/div&gt; &lt;/body&gt; 三种引用方式：如果使用内部样式表，样式只需要写一遍；但是如果使用行内样式，则每个元素要单独写一遍。 行内样式是在每一个元素内部定义的，冗余代码非常多，并且每次改动CSS的时候，必须到元素中一个个去改，这样会导致网站的可读性和可维护性非常差。 对于这三种样式表，在实际开发中，一般都是使用外部样式表。 CSS选择器元素的id和class属性在HTML中，id和class是元素最基本的两个属性。一般，id和class都是用来选择元素，以便进行CSS操作或者JavaScript操作。 id属性id属性具有唯一性，也就是说在一个页面中相同的id只能出现一次。如果出现了多个相同的id，那么CSS或者JavaScript就无法识别这个id对应的是哪一个元素。 如： &lt;div id=&quot;2233&quot; &gt;test&lt;/div&gt; 同一个页面中，不允许出现两个相同id的元素。在不同页面中，可以出现两个id相同的元素。 class属性class，”类“。为同一个页面的相同元素或者不同元素设置相同的class，然后使得相同class的元素具有相同的CSS样式。 &lt;p class=&quot;6666&quot;&gt;test&lt;/p&gt; 在同一个页面中，允许出现两个相同class的元素。可以对具有相同class的多个元素，定义相同的CSS样式。 css选择器入门：5种实用的选择器： （1）元素选择器（2）id选择器（3）class选择器（4）后代选择器（5）群组选择器 元素选择器元素选择器，就是选中相同的元素，然后对相同的元素定义同一个CSS样式。 语法： div{colr:blue;width:100px} 元素符号{属性：属性值；} &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;/&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; div{color:blue;} &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;南翊&lt;/div&gt; &lt;p&gt;南翊&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; div{color:blue;}表示把页面中所有的div元素选中，然后定义它们文本颜色为蓝色。 元素选择器就是选择指定的相同的元素，而不会选择其他元素。上面例子中的p元素没有被选中，因此这两个元素文本颜色就没有变蓝。 id选择器为元素设置一个id属性，然后针对设置了这个id的元素定义CSS样式，这就是id选择器。在同一个页面中，是不允许出现两个相同的id的。 对于id选择器，id名前面必须要加上前缀“#”，否则该选择器无法生效。id名前面加上“#”，表示这是一个id选择器。 语法示例： &lt;style type=&quot;text/css&quot;&gt; #NANIVY{color:red;} &lt;/style&gt; &lt;div id=&quot;NANIVY&quot;&gt;TEST &lt;/div&gt; 选中id为NANIVY的元素并定义文本为红色。 class选择器 .类选择器。对“相同的元素”或者“不同的元素”定义相同的class属性，然后针对拥有同一个class的元素进行CSS样式操作。 class名前面必须要加上前缀英句号（.），否则该选择器无法生效。类名前面加上英文句号，表明这是一个class选择器。 &lt;style type=&quot;text/css&quot;&gt; .ivy{color:red;} &lt;div class=&quot;lvy&quot;&gt;绿叶学习网&lt;/div&gt; &lt;div class=&quot;lvy&quot;&gt;绿叶学习网&lt;/div&gt; 要为两个或多个元素定义相同的样式，建议使用class选择器，因为这样可以减少大量重复代码。 后代选择器后代选择器，就是选择元素内部中所有的某一种元素，包括子元素和其他后代元素 父元素和后代元素必须要用空格隔开，从而表示选中某个元素内部的后代元素。 &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; #father span{color:blue;} &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;father&quot;&gt; &lt;p&gt;test&lt;/p&gt; &lt;p&gt;test&lt;/p&gt; &lt;span&gt;test&lt;/span&gt; &lt;/div&gt; &lt;/body&gt; #father span{ color:blue;}表示选择“id为father的元素”下的所有span元素，然后定义它们文本颜色为蓝色。 用”类“语法同理如： .sks span{color:green;} ——sks类下的span全部绿色。 群组选择器群组选择器，指的是同时对几个选择器进行相同的操作。对于群组选择器，两个选择器之间必须要用英文逗号（,）隔开，不然群组选择器就无法生效。 &lt;style type=&quot;text/css&quot;&gt; h3,p,span{color:red;} &lt;/style&gt; 等价于 &lt;style type=&quot;text/css&quot;&gt; h3{color:red;} p{color:red;} span{color:red;} &lt;/style&gt; 群组选择器中加入#.等选择器同样适用。 CSS字体字体相关css属性 属性 说明 font-family 字体类型 font-size 字体大小 font-weight 字体粗细 font-style 字体风格 color 字体颜色 font就是字体的意思：理解性记忆，根据英文理解，事半功倍。 font-family：字体类型font-family: 字体1,字体2,……字体n; 一般浏览器默认”宋体“；还有微软雅黑啊什么的，，，， 对于font-family属性，如果字体类型只有一个英文单词，则不需要加上双引号；如果字体类型是多个英文单词或者中文的，则需要加上双引号。 比如： “微软雅黑”、 “Times New Roman”或是Georgia、Arial这样就不用引号。 另外： p{font-family:A,B,C;} p元素优先使用“A字体”来显示，如果电脑没有装“A字体”，那就接着考虑“B字体”。……以此类推。如果都没有安装，那么p元素就会以默认字体（即宋体）来显示。 实际开发，比较美观的中文字体有微软雅黑、苹方，英文字体有Times New Roman 、Arial和Verdana。 font-size：字体大小font-size: 像素值; font-size属性取值有两种： ①“关键字”，如small、medium、large等； ②“像素值”，如10px、16px、20px等。（谷歌默认16px） px即像素（pixel），一般采用像素作为单位。还有em、百分比了解下就行。 font-weight：字体粗细font-weight: 取值; 同上，也是有两种取值，关键字和数值： 关键字如：normal（正常）、lighter（较细）、bold（较粗）、bolder（很粗）。常用 bold（较粗）。 数值：100-900的取值（400-100-700-900）和上关键词依次对应。 font-style：字体风格font-style: 取值; 取值： normal（正常）、italic（斜体）、oblique（斜体） 两个斜体效果几乎一样，只不过两者的区别是对字体的支持不一样；有些没有italic属性，这时就能通过oblique让没有italic属性的字体也能够有斜体效果。 color：字体颜色color: 颜色值; 入门的两种取值：关键字、16进制RGB 关键字：就是英文单词red，blue，pink等等，vscode有代码提示。 RGB值：如#000000、#FFFFFF等形式的取值 ，可自行了解 tips：浏览器解析css是按一定顺序来，后来的可能会覆盖前面的 CSS文本样式文本是文本，文字是文字。 常见文本样式： 属性 说明 text-indent 首行缩进 text-align 水平对齐 text-decoration 文本修饰 text-transform 大小写转换 line-height 行高 letter-spacing 字母间距 word-spacing 词间距 text-indent：首行缩进为了替代之前说的p标签的六个&amp; nbsp;来进行首行缩进。使用css中的text-indent属性来定义p元素的首行缩进。 text-indent: 取值; 取值有多种单位，入是推荐使用像素px作为单位；按照设定的字体大小，即font-size的两倍，即开头空两个字了。 text-align：水平对齐text-align: 取值; 该属性用于控制文本水平方向上的对齐方式。 入门学习取值： left（左对齐，默认属性）、center（居中对齐）、right（右对齐）。该属性对图片（img）也有效。 text-decoration：文本修饰入门学习 text-decoration: 取值; 取值：underline（下划线）、line-through（中划线）、overline（顶划线，不常见）、none（默认，无划线） 虽然可以使用s、u等标签，但还是尽量把结构和样式分开好。 同时可以使用none去掉超链接的下划线，如： a{text-decoration:none;} text-transform：大小写转换text-transform: 取值; 取值： none（默认，无），uppercase（转换为大写），lowercase（转换为小写），capitalize（只把每个英文单词首字母大写）。 line-height：行高（行间距）line-height: 像素值; 取值，10px、20px等等。 letter-spacing：字间距letter-spacing: 像素值; 取值，2px、5px等等。 调整每个字之间的间距，一个字母算一个字。 word-spacing：词间距word-spacing: 像素值; 单词间距，针对英语单词的间距。 CSS边框样式几乎所有的元素都可以定义边框。 div元素可以定义边框，img元素可以定义边框，table元素可以定义边框，span元素同样也可以定义边框等等…… 属性 说明 border-width 边框的宽度 border-style 边框的外观 border-color 边框的颜色 想要为一个元素定义边框样式，必须要同时设置border-width、border-style、border-color属性才会有效果。 border-width：边框的宽度border-width属性用于定义边框的宽度，取值是像素值。 border-style：边框的外观入门取值：none（无）、dashed（虚线）、solid（实线） border-color：边框的颜色border-color属性用于定义边框的颜色，取值可以是“关键字”或“16进制RGB值”。 示例&amp;简写： div{ border-width:1px; border-style:solid; border-color:red; } 简写形式： img{border: 1px solid red;} 局部样式边框如： 上边框：border-top border-top-width: 1px; border-top-style: solid; border-top-color: red; 简写： border-top: 1px solid red; 上边框border-top、下边框border-bottom、左边框border-left、右边框border-right 混合使用： div { border:2px solid green; border-bottom:10px dashed red; border-top:0px; } 左右绿色实线，下红色虚线,上线取消 关于取消单边的线：border-bottom:0px;、border-bottom:0;和border-bottom:none;是等价的。 CSS列表样式list-style-typelist-style-type: 取值; 例子： &lt;style type=&quot;text/css&quot;&gt; ol{list-style-type:lower-roman;} &lt;/style&gt; 不管有序列表还是无序列表都能用这个；（针对ol/ul元素） 一般ol（有序列表）取值： decimal（默认，阿拉伯数1，2，3.。。） lower-roman/upper-roman（小写/大写罗马：i、ii、iii…/I、II、III…） lower-alpha/lower-alpha( 小写/大写英文字母) none（无，去掉） ul（无序列表）取值： disc（ 实心圆●，默认值） circle（空心圆○） square（正方形■） none（无，去掉） 例子（有序，大写罗马）： one two three &lt;ol style=&quot;list-style-type:upper-roman;&quot;&gt; &lt;li&gt;one&lt;/li&gt; &lt;li&gt;two&lt;/li&gt; &lt;li&gt;three&lt;/li&gt; &lt;/ol&gt; list-style-imagelist-style-image: url(图片路径); 使用图片代替列表项符号；如： one two &lt;ul style=&quot;list-style-image:url(https://cdn.jsdelivr.net/gh/0NanIvy0/cdn@1.3/ico/favicon.ico);&quot;&gt; &lt;li&gt;one&lt;/li&gt; &lt;li&gt;two&lt;/li&gt; &lt;/ul&gt; CSS表格样式caption-side：表格标题位置caption-side: 取值; 例子： table{caption-side:bottom;} ^ | &lt;caption&gt;表格标题&lt;/caption&gt; 标题会在底部 取值：top（标题在顶部，默认） bottom（标题在底部） 在table或caption这两个元素的CSS中定义caption-side属性，效果是一样的。 border-collapse：表格边框合并border-collapse: 取值; border-collapse属性是在table元素中定义的。 取值： separate（默认，边框分开） collapse（边框合并，无空隙） border-spacing：表格边框间距border-spacing: 像素值; border-spacing属性是在table元素中定义的。 在不合并边框的情况下来控制边框间距. CSS图片样式定义图片大小width: 像素值; height: 像素值; img {width: 20px;height: 30px;} 图片边框border: 1px solid red; img{border: 1px solid red;} 参考css边框样式，同理。 对齐方式水平对齐：text-align: 取值; 取值：left,center,right 图片对齐不在img中，而在父元素中进行： #duiqi{ text-align: center; } &lt;div id=&quot;duiqi&quot;&gt; &lt;img src=&quot; img/girl.gif&quot; alt=&quot;&quot;/&gt; &lt;/div&gt; 垂直对齐：vertical-align: 取值; vertical（垂直的） 取值： top（顶部），middle（中部），bottom（底部）,baseline（基线） 四种对齐方式展示： bilibili哔哩哔哩干杯！~~~ bilibili哔哩哔哩干杯！~~~ bilibili哔哩哔哩干杯！~~~ bilibili哔哩哔哩干杯！~~~ 图片文字环绕float: 取值; 取值：left（图片靠左浮动），right（图片靠右浮动） 在img元素中定义。 CSS背景样式background-color： 背景颜色定义元素的背景颜色 background-color: 颜色值; div{background-color: pink;} 关键字/16RBG等等…… 可以给文本加背景色，就像书本上被荧光笔标记了一样（加上的效果类似于被选中的感觉）如： 黄绿色背景 猛男色背景 background-image：背景图片样式background-image: url(图片路径); div{background-image: url(xxx.XXX.XXX);} 引入图片后也要设置width和height才会显示背景图片。 即： div{width:233px;height:233px;background-image: url(xxx);} 或者 body { background-image:url(xxx); } 效果： 哔哩哔哩干杯！ background-repeat：背景图片重复background-repeat: 取值; 取值： repeat（默认：水平，垂直方向都平铺） repeat-x（只在水平（x轴），平铺） repeat-y（垂直平铺） no-repeat（不平铺） 元素的宽度和高度必须大于背景图片的宽度和高度，才会有重复效果。如：300*150px只在水平平铺 哔哩哔哩干杯！ background-position：背景图片位置background-position: 像素值/关键字; 像素：background-position: 水平距离 垂直距离; background-position:233px 666px 关键字：background-position: 水平距离（行：上中下） 垂直距离（列：左中右）; 划分为3*3格 关键字：top ，center， bottom ，left， right 示例： 哔哩哔哩干杯！ background-attachment：背景图片固定background-attachment: 取值; 取值：scroll（默认；随元素一起滚动），fixed（固定不动） 会决定背景图片会不会随着元素一起滚动。 CSS超链接样式超链接CSS伪类定义超链接在鼠标点击的不同时期的样式 a:link{…} 定义a元素未访问时的样式 a:visited{…} 定义a元素访问后的样式 a:hover{…} 定义鼠标经过a元素时的样式 a:active{…} 定义鼠标点击激活时的样式 定义时一定要按以上顺序依次进行，不然可能浏览器会出错。 如： &lt;style type=&quot;text/css&quot;&gt; a{text-decoration:none;} a:link{color:pink;} a:visited{color:purple;} a:hover{color:red;} a:active{color:green;} &lt;/style&gt; 但也不是什么时候都需要把4个都定义了 未访问状态颜色也可以直接在a中定义了，如： a { color:blue; text-decoration: none; } a:hover { color:pink; text-decoration:underline; } ：hover除了用于超链接，同样适用其他标签，即鼠标经过时候的样式： div:hover { background-color: hotpink; } 如经过div时出现背景色 img:hover { border:2px solid red; } 经过图片时显示边框 鼠标样式浏览器鼠标样式（电脑自带样式？） cursor: 取值; div{cursor:pointer;} &lt;div&gt;珈 窝 刊 梅 洋 洋 洗 枣&lt;/div&gt; 记住default（默认鼠标），pointer（指向鼠标，一只手点击的样子），text（选中文本的样子）就行，扩展自行百度。 自定义鼠标样式cursor: url(图片地址), 属性值; 图片后缀一般为cur，属性值如上记住3个重点即可。 CSS盒子模型盒子模型CSS盒模型本质上是一个盒子，封装周围的HTML元素，它包括：边距，边框，填充，和实际内容。 盒模型允许我们在其它元素和周围元素边框之间的空间放置元素。 页面中的所有元素都可以看成一个盒子，并且占据着一定的页面空间。每个元素都看成一个盒子，盒子模型是由四个属性组成的：content（内容）、padding（内边距）、margin（外边距）和border（边框）。此外，在盒子模型中，还有宽度width和高度height两大辅助性属性。 记住，所有的元素都可以看成一个盒子。（body都是） 属性 说明 content 内容，可以是文本或图片 padding 内边距，用于定义内容与边框之间的距离 margin 外边距，用于定义当前元素与其他元素之间的距离 border 边框，用于定义元素的边框 内容区（content） 内容区是CSS盒子模型的中心，它呈现了盒子的主要信息内容，这些内容可以是文本、图片等多种类型。内容区是盒子模型必备的组成部分，其他3个部分都是可选的。 内边距（padding） 内边距，指的是内容区和边框之间的空间。 外边距（margin） 外边距，指的是两个盒子之间的距离，它可能是子元素与父元素之间的距离，也可能是兄弟元素之间的距离。外边距使得元素之间不必紧凑地连接在一起，是CSS布局的一个重要手段。 边框（border） 同之前学的边框。 内容：宽（width）高（height）元素的宽度和高度是针对内容而定；只有块元素才可以设置width和height，行内元素无法设置width和height。 如： div{width:100px;height:50px;} 若想为行内元素设置宽高，可用display属性把行内元素转化为块元素，css入门先不管。、 display:inline-block; 把元素转化为inline-block元素。 边框：borderborder: 1px solid red; 前面的笔记有详细。 内边距：padding又被称为“补白”，指的是内容区到边框之间的一部分。内边距都是在边框内部的。 padding局部样式同边框一样，可以分上下左右四个边进行分别调节： padding-top: 值; padding-right: 值; padding-bottom: 值; padding-left: 值; padding的简写有三种简写方式： padding: 值; padding: 值1 值2; padding: 值1 值2 值3 值4; 第一种，即4个方向都是一个值。取值前期还是考虑像素px。 第二种，表示上下为值1，左右为值2。 第三种，表示从上开始顺时针方向：上右底左依次是1234对应值。 外边距：margin边框到“父元素”或“兄弟元素”之间的那一部分。外边距是在元素边框的外部的。 margin局部样式同内边距，分为上下左右四个部分。 margin-top: 值; margin-right: 值; margin-bottom: 值; margin-left: 值; margin简写形式margin: 值; margin: 值1 值2; margin: 值1 值2 值3 值4; 介绍同上padding CSS浮动布局浮动在之前图片样式里面已经提到过“环绕-float了”。 浮动是CSS布局的利器，通过浮动来灵活地定位页面元素，以达到布局网页的目的。 如我们可以通过设置float属性让元素向左浮动或者向右浮动，以便让周围的元素或文本环绕着这个元素。 float: 取值; 取值：left，right。 如：将div设置为浮动元素，则其对应的宽度将不在延申，而是由内容决定宽度，同时会相邻的下一个div会紧贴该元素，这就是浮动二引起的效果。 清除浮动浮动会影响周围元素，并且还会引发很多预想不到的问题。在CSS中，可以使用clear属性来清除浮动带来的影响。 clear: 取值; 取值：left，right，both（去除左，右，同时去掉浮动） 一般直接简单除暴clear：both清除该元素的兄弟元素浮动之后带来的影响。 &lt;div&gt; &lt;div id=&quot;box1&quot;&gt;box1&lt;/div&gt; &lt;div id=&quot;box2&quot;&gt;box2&lt;/div&gt; &lt;div class=&quot;clear&quot;&gt;&lt;/div&gt; &lt;/div&gt; 一般增加一个空元素来专门clear.除了clear还有其他方式，这里入门先接触一个。 CSS定位布局定位布局可以将一个元素精确地放在页面上指定的地方。联合使用定位和浮动，能够创建多种高级而精确地布局。定位布局共有4种方式。 固定定位：fixed所谓的固定定位，指的是被固定的元素不会随着滚动条的拖动而改变位置。用来做”回到顶部“挺好。 position: fixed; top: 值; bottom: 值; left: 值; right: 值; position:fixed;是结合top、bottom、left和right这4个属性一起使用的。其中，position:fixed使得元素成为固定定位元素，接着使用top、bottom、left和right这4个属性来设置元素相对浏览器的位置。一般不会四个都用。 比如left：40px就是在距浏览器左部的40px；top：400px就是离顶部400px的位置。 相对定位：relative相对定位，指该元素的位置是相对于它的原始位置计算而来的。 position: relative; top: 值; bottom: 值; left: 值; right: 值; 绝对定位：absolute一个元素变成了绝对定位元素，这个元素就完全脱离文档流了，绝对定位元素的前面或后面的元素会认为这个元素并不存在，此时这个元素浮于其他元素上面，已经完全独立出来了。 position: absolute; top: 值; bottom: 值; left: 值; right: 值; 取值同固定定位，但会随滚动条滚动。 静态定位：static在默认情况下，元素没有指定position属性时，这个元素就是静态定位的。也就是说，元素position属性的默认值是static。 一般情况下我们使用不到position:static的，不过在使用JavaScript来控制元素定位时，如果想要使得元素从其他定位方式变成静态定位，就需要使用position:static来实现。","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"学习","slug":"学习","permalink":"/tags/学习/"},{"name":"CSS","slug":"CSS","permalink":"/tags/CSS/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"前端学习笔记——HTML基础","slug":"前端学习笔记——HTML基础","date":"2021-07-13T01:07:22.000Z","updated":"2021-09-12T14:05:28.845Z","comments":true,"path":"2021/07/13/前端学习笔记——HTML基础/","link":"","permalink":"/2021/07/13/前端学习笔记——HTML基础/","excerpt":"","text":"参考学习路线：https://zhuanlan.zhihu.com/p/324351537 对前端初恋的感觉——绿叶学习网：http://www.lvyestudy.com/ HTML基本标签head标签在HTML中，一般来说，只有6个标签能放在head标签内。 ①title标签​ 在HTML中，title标签唯一的作用就是定义网页的标题。 ②meta标签关键词，给搜索引擎。 在HTML中，meta标签有两个重要的属性：name和http-equiv。 name属性 属性值 说明 keywords 网页的关键字，可以是多个，而不仅仅是一个 description 网页的描述 author author copyright 版权信息 重点记住keywords，description。 http-equiv属性在HTML中，meta标签的http-equiv属性只有两个重要作用：定义网页所使用的编码；定义网页自动刷新跳转。 （1）定义网页所使用的编码 语法： &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;/&gt; 说明： 这段代码告诉浏览器该页面所使用的编码是utf-8。不过在HTML5标准中，上面这句代码可以简写为： &lt;meta charset=&quot;utf-8&quot; /&gt; 如果你发现页面打开是乱码，很可能就是没有加上这一句代码。在实际开发中，为了确保不出现乱码，我们必须要在每一个页面中加上。 （2）定义网页自动刷新跳转 语法： &lt;meta http-equiv=&quot;refresh&quot; content=&quot;6;url=http://www.baidu.com&quot;/&gt; 说明： 这段代码表示当前页面在6秒后会自动跳转到http://www.baidu.com这个页面。实际上，很多“小广告”网站就是用这个来实现页面定时跳转的。 ③link标签在HTML中，link标签用于引入外部样式文件（CSS文件）。这也是属于CSS部分的内容，这里不需要深究。 ④style标签在HTML中，style标签用于定义元素的CSS样式，在HTML中不需要深入研究。 ⑤script标签在HTML中，script标签用于定义页面的JavaScript代码，也可以引入外部JavaScript文件。在JavaScript部分详细学习，这里不需要深究。 ⑥base标签这个标签一点意义都没有，可以直接忽略，知道有这么一个标签就行了。 HTML文本标签标题h1~6 这里要注意一下，一个页面一般只能有一个h1标签，而h2到h6标签可以有多个。其中，h1表示的是这个页面的大标题。 &lt;body&gt; &lt;h1&gt;这是一级标题&lt;/h1&gt; &lt;h2&gt;这是二级标题&lt;/h2&gt; &lt;h3&gt;这是三级标题&lt;/h3&gt; &lt;h4&gt;这是四级标题&lt;/h4&gt; &lt;h5&gt;这是五级标题&lt;/h5&gt; &lt;h6&gt;这是六级标题&lt;/h6&gt; &lt;/body&gt; 段落标签段落标签 &lt;p&gt;&lt;/p&gt; 换行标签 &lt;br/&gt; 文本标签 （1）粗体标签：strong、b strong标签和b标签的加粗效果是一样的。不过在实际开发中，如果想要对文本实现加粗效果，尽量使用strong标签，而不要使用b标签。这是因为strong标签比b标签更具有语义性。 （2）斜体标签：i、em、cite 在实际开发中，如果想要实现文本的斜体效果，尽量使用em标签，而不是i标签或cite标签。这也是因为em标签比其他两个标签的语义性更好。 （3）上标标签：sup 如果你想要将某个数字或某些文字变成上标效果，只要把这个数字或文字放在标签内就可以了。 如：&lt;p&gt;(a+b)&lt;sup&gt;2&lt;/sup&gt;=a&lt;sup&gt;2&lt;/sup&gt;+b&lt;sup&gt;2&lt;/sup&gt;+2ab&lt;/p&gt; （4）下标标签：sub 同理。 （5）中划线标签：s 中划线效果一般用于显示那些不正确或者不相关的内容，常用于商品促销的标价中。大家在电商网站购物时肯定经常见到这种效果。 不过等学了CSS之后，对于删除线效果，一般用CSS来实现，几乎不会用s标签来实现。 &lt;p&gt;&lt;s&gt;原价:￥6.50/kg&lt;/s&gt;&lt;/p&gt; （6）下划线标签：u 等学了CSS之后，对于下划线效果，一般用CSS来实现，几乎不会用u标签来实现。 &lt;p&gt;&lt;u&gt;啊啊啊&lt;/u&gt;Web技术学习&lt;/p&gt; （7）大字号标签：big （8）小字号标签：small 重要的文本标签 标签 语义 说明 strong strong（强调） 粗体 em emphasized（强调） 斜体 sup superscripted（上标） 上标 sub subscripted（下标） 下标 水平线标签是 &lt;hr/&gt; div标签在HTML中，我们可以使用“div标签”来划分HTML结构，从而配合CSS来整体控制某一块的样式。div标签最重要的用途是划分区域，然后结合CSS针对该区域进行样式控制，这一点我们学了CSS才会知道。 块元素和行内元素标签，也叫“元素”，例如p标签又叫p元素。叫法不同，意思相同。 在HTML中，根据元素的表现形式，一般可以分为两类（暂时不考虑inline-block）。 （1）块元素（block） 在HTML中，块元素在浏览器显示状态下将占据整一行，并且排斥其他元素与其位于同一行。此外，一般情况下，块元素内部可以容纳其他块元素和行内元素。(非全部) 块元素 说明 h1~h6 标题元素 p 段落元素 div div元素 hr 水平线 ol 有序列表 ul 无序列表 （1）块元素独占一行，排斥其他元素（包括块元素和行内元素）与其位于同一行。 （2）块元素内部可以容纳其他块元素和行内元素。 （2）行内元素（inline） 在HTML中，行内元素跟块元素恰恰相反，行内元素是可以与其他行内元素位于同一行的。此外，行内元素内部（标签内部）只可以容纳其他行内元素，不可以容纳块元素。(常见) 行内元素 说明 strong 粗体元素 em 斜体元素 a 超链接 span 常用行内元素，结合CSS定义样式 （1）行内元素可以与其他行内元素位于同一行。 （2）行内元素内部可以容纳其他行内元素，但不可以容纳块元素。 特殊符号空格： &amp;nbsp ; 敲黑板 其他随便了解就行 不一定非要代码 可以直接输入。 HTML列表有序列表在HTML中，有序列表中的各个列表项是有顺序的。有序列表从 ol 开始，到 /ol 结束。有序列表的列表项是有先后顺序的，一般采用数字或字母作为顺序，默认是采用数字顺序。 &lt;ol&gt; &lt;li&gt;列表项&lt;/li&gt; &lt;li&gt;列表项&lt;/li&gt; &lt;li&gt;列表项&lt;/li&gt; &lt;/ol&gt; ol，即ordered list（有序列表）；li，即list（列表项）。 在HTML中，我们可以使用type属性来改变列表项符号。默认情况下，有序列表使用数字作为列表项符号。 属性值 列表项符号 1 阿拉伯数字：1、2、3…… a 小写英文字母：a、b、c…… A 大写英文字母：A、B、C…… i 小写罗马数字：i、ii、iii…… I 大写罗马数字：I、II、III…… 对于有序列表的列表项符号，等学了CSS之后，我们可以放弃type属性，而使用list-style-type属性。 无序列表无序列表，很好理解，有序列表的列表项是有一定顺序的，而无序列表的列表项是没有顺序的。默认情况下，无序列表的列表项符号是●，不过可以通过type属性来改变其样式。 &lt;ul&gt; &lt;li&gt;列表项&lt;/li&gt; &lt;li&gt;列表项&lt;/li&gt; &lt;li&gt;列表项&lt;/li&gt; &lt;/ul&gt; ul，即unordered list（无序列表）。li，即list（列表项）。 在无序列表中，type属性取值如下表所示。 属性值 列表项符号 disc 实心圆●（默认值） circle 空心圆○ square 正方形■ 跟有序列表一样，对于无序列表的列表项符号，等学了CSS之后，可以放弃type属性，而使用list-style-type属性。 此外，对于无序列表来说，还有以下两点要注意： （1）ul元素的子元素只能是li，不能是其他元素。 （2）ul元素内部的文本，只能在li元素内部添加，不能在li元素外部添加。 定义列表在HTML中，定义列表由两部分组成：名词和描述。 &lt;dl&gt; &lt;dt&gt;名词&lt;/dt&gt; &lt;dd&gt;描述&lt;/dd&gt; …… &lt;/dl&gt; dl即definition list（定义列表）；dt即definition term（定义名词）；而dd即definition description（定义描述）。 在实际开发中，定义列表虽然用得比较少，但是在某些高级效果（如自定义表单）中也会用到。在HTML入门阶段，了解一下就行。 HTML表格基本结构在HTML中，一个表格一般会由以下3个部分组成。 （1）表格：table标签 （2）行：tr标签 （3）单元格：td标签 tr，指的是table row（表格行）；td，指的是table data cell（表格单元格）。 由table和/table表示整个表格的开始和结束，tr和/tr表示行的开始和结束，而td和/td表示单元格的开始和结束。 在表格中，有多少组“tr /tr”，就表示有多少行。 &lt;table&gt; &lt;tr&gt; &lt;td&gt;单元格1&lt;/td&gt; &lt;td&gt;单元格2&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;单元格3&lt;/td&gt; &lt;td&gt;单元格4&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; 单元格1 单元格2 单元格3 单元格4 表格标题：caption一个表格只能有一个标题，也就是只能有一个caption标签。在默认情况下，标题都是位于整个表格内的第一行。 如： &lt;table&gt; &lt;caption&gt;表格标题&lt;/caption&gt;。。。。。。。&lt;/table&gt; 表头单元格：th在HTML中，单元格其实有两种：表头单元格，使用th标签；表行单元格，使用td标签。 th，指的是table header cell（表头单元格）。td，指的是table data cell（表行单元格）。 th和td在本质上都是单元格，但是并不代表两者可以互换，两者具有以下两种区别。 当然，对于表头单元格，可能会使用td来代替th，但是不建议这样做。学习HTML的目的就是，在需要的地方用到正确的标签（也就是语义化）。 &lt;body&gt; &lt;table&gt; &lt;caption&gt;考试成绩表&lt;/caption&gt; &lt;tr&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;语文&lt;/th&gt; &lt;th&gt;英语&lt;/th&gt; &lt;th&gt;数学&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;小明&lt;/td&gt; &lt;td&gt;80&lt;/td&gt; &lt;td&gt;80&lt;/td&gt; &lt;td&gt;80&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;小红&lt;/td&gt; &lt;td&gt;90&lt;/td&gt; &lt;td&gt;90&lt;/td&gt; &lt;td&gt;90&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;小杰&lt;/td&gt; &lt;td&gt;100&lt;/td&gt; &lt;td&gt;100&lt;/td&gt; &lt;td&gt;100&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; 表格语义化一个完整的表格包含：table、caption、tr、th、td。为了更深一地对表格进行语义化，HTML引入了thead、tbody和tfoot标签。 thead、tbody和tfoot把表格划分为3部分：表头、表身、表脚。有了这些标签，表格语义更加良好，结构更加清晰，也更具有可读性和可维护性。 &lt;table&gt; &lt;caption&gt;表格标题&lt;/caption&gt; &lt;!--表头--&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;表头单元格1&lt;/th&gt; &lt;th&gt;表头单元格2&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;!--表身--&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;表行单元格1&lt;/td&gt; &lt;td&gt;表行单元格2&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;表行单元格3&lt;/td&gt; &lt;td&gt;表行单元格4&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;!--表脚--&gt; &lt;tfoot&gt; &lt;tr&gt; &lt;td&gt;标准单元格5&lt;/td&gt; &lt;td&gt;标准单元格6&lt;/td&gt; &lt;/tr&gt; &lt;/tfoot&gt; &lt;/table&gt; 表脚（tfoot）往往用于统计数据的。对于thead、tbody和tfoot标签，不一定全部都上，例如tfoot就很少用。一般情况下，我们都是根据实际需要来使用这些标签。 thead、tbody和tfoot标签也是表格中非常重要的标签，它从语义上区分了表头、表身和表脚，很多人容易忽略它们。 此外，thead、tbody和tfoot除了使得代码更具有语义之外，还有另外一个重要作用：方便分块来控制表格的CSS样式。 合并行：rowspan在设计表格时，有时我们需要将“横向的N个单元格”或者“纵向的N个单元格”合并成一个单元格（类似word的表格合并），这个时候就需要用到“合并行”或“合并列”。这一节，我们先来介绍一下合并行。 在HTML中，我们可以使用rowspan属性来合并行。所谓的合并行，指的是将“纵向的N个单元格”合并。 语法： &lt;td rowspan = &quot;跨越的行数&quot;&gt;&lt;/td&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;姓名:&lt;/td&gt; &lt;td&gt;小明&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td rowspan=&quot;2&quot;&gt;喜欢水果:&lt;/td&gt; &lt;td&gt;苹果&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;香蕉&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; 合并列：colspan在HTML中，我们可以使用colspan属性来合并列。所谓的合并列，指的是将“横向的N个单元格”合并。 语法 &lt;td colspan = &quot;跨越的列数&quot;&gt;&lt;/td&gt; &lt;table&gt; &lt;tr&gt; &lt;td colspan=&quot;2&quot;&gt;前端开发&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;HTML&lt;/td&gt; &lt;td&gt;CSS&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;JavaScript&lt;/td&gt; &lt;td&gt;jQuery&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; ​ HTML图片图片标签任何网页都少不了图片，一个图文并茂的页面，可以使得用户体验更好。如果想让网站获得更多的流量，也需要从“图文并茂”这个角度挖掘一下。 在HTML中，我们可以使用img标签来显示一张图片。对于img标签，只需要掌握它的3个属性：src、alt和title。 语法 &lt;img src=&quot;&quot; alt=&quot;&quot; title=&quot;&quot; /&gt; src属性src用于指定这个图片所在的路径，这个路径可以是相对路径，也可以是绝对路径。 任何一个图片必须指定src属性才可以显示。也就是说，src是img标签必不可少的属性。 alt属性和title属性alt和title都是用于指定图片的提示文字。一般情况下，alt和title的值是相同的。不过两者也有很大的不同。 alt：&lt;!DOCTYPE html&gt; 实际上，当我们把“img/xxx.png”去掉（也就是图片无法显示）后，此时可以看到浏览器会显示alt的提示文字，如下图所示。如果没有加上alt属性值，图片不显示时，就不会有提示文字。 title：当我们把鼠标移到图片上时，就会显示title中的提示文字，如下所示。 &lt;!DOCTYPE html&gt; 在实际开发中，对于img标签，src和alt这两个是必选属性，一定要添加；而title是可选属性，可加可不加。 alt属性的内容是提供给搜索引擎看的，title属性的内容是提供给用户看的 图片路径相对路径： 绝对路径： 在实际开发中，站内文件不管是图片还是超链接等,都是使用相对路径，几乎不会使用绝对路径。 这是因为如果采用绝对路径，网站文件一旦移动，则所有的路径都可能会失效。因此，只需要掌握相对路径，而绝对路径了解一下就行。 图片格式在网页中，图片格式有两种：一种是“位图”；另外一种是“矢量图”。 位图位图，又叫做“像素图”，它是由像素点组成的图片。对于位图来说，放大图片后，图片会失真；缩小图片后，图片同样也会失真。 在实际开发中，最常见位图的图片格式有3种（可以从图片后缀名看出来）：jpg（或jpeg）、png、gif。深入理解3种图片适合在哪种情况下使用，在前端开发中是非常重要的。 （1）jpg可以很好地处理大面积色调的图片，适合存储颜色丰富的复杂图片，如照片、高清图片等。此外，jpg体积较大，并且不支持透明。 （2）png是一种无损格式，可以无损压缩以保证页面打开速度。此外，png体积较小，并且支持透明，不过不适合存储颜色丰富的图片。 （3）gif图片效果最差，不过它适合制作动画。实际上，小伙伴们经常在QQ或微信上发的动图都是gif格式的。 这里来总结一下：如果想要展示色彩丰富而高品质图片，可以使用jpg格式；如果是一般图片，为了减少体积或者想要透明效果，可以使用png格式；如果是动画图片，可以使用gif格式。 矢量图矢量图，又叫做“向量图”，它是用计算机图形学中点、直线或多边形等表示出来的几何图像。 矢量图是以一种数学描述的方式来记录内容的图片格式。举个例子，可以使用y=kx来绘制一条直线，当k取不同值时就会绘制不同角度的直线，这就是矢量图的构图原理。 矢量图最大的优点是：图片无论放大、缩小或旋转等都不会失真。最大的缺点是：难以表现色彩丰富的图片效果（非常差）。 矢量图常见格式有：“.ai”、“.cdf”、“.fh”、“.swf”。其中“.swf”格式比较常见，它指的是Flash动画，其他几种格式的矢量图比较少见，可以忽略。对于矢量图，我们可以使用illustrator或者CorelDRAW这两款软件来处理。 在网页中，很少用到矢量图，除非是一些字体图标（iconfont）。不过作为初学者，只需简单了解一下即可。 对于位图和矢量图的区别，我们总结有以下4点。 （1）位图适用于展示色彩丰富的图片，而矢量图不适用于展示色彩丰富的图片。 （2）位图组成单位是“像素”，而矢量图组成单位是“数学向量”。 （3）位图受分辨率影响，当图片放大时会失真；而矢量图不受分辨率影响，当图片放大时不会失真。 （4）网页中的图片绝大多数都是位图，而不是矢量图。 HTML超链接a标签语法： &lt;a href=&quot;链接地址&quot;&gt;文本或图片&lt;/a&gt; href表示你想要跳转到那个页面的路径（也就是地址），可以是相对路径，也可以是绝对路径。 超链接的范围非常广，可以将文本设置为超链接，这个叫做“文本超链接”。也可以将图片设置为超链接，这个叫做“图片超链接”。 target属性 默认情况下，超链接都是在当前浏览器窗口打开新页面的。在HTML中，我们可以使用target属性来定义超链接打开窗口的方式。 语法： &lt;a href=&quot;链接地址&quot; target=&quot;打开方式&quot;&gt;&lt;/a&gt; a标签的target属性取值有4种，如下表所示。 属性值 说明 _self 默认值，在原来窗口打开链接 _blank 在新窗口打开链接 _parent 在父窗口打开链接 _top 在顶层窗口打开超链接 一般情况下，只会用到_blank这一个值，也只要记住这一个就够了，其他三个值不需要去深究。默认的self，可加可不加。 锚点链接有些页面内容比较多，导致页面过长，此时用户需要不停拖动浏览器上的滚动条才可以看到下面的内容。为了方便用户操作，可以使用锚点链接来优化用户体验。 在HTML中，锚点链接其实是内部链接的一种，它链接地址（也就是href）指向的是当前页面的某个部分。所谓的锚点链接，简单来说，就是点击某一个超链接，然后它就会跳到当前页面的某一部分。 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; &lt;a href=&quot;#article&quot;&gt;推荐文章&lt;/a&gt;&lt;br /&gt; &lt;a href=&quot;#music&quot;&gt;推荐音乐&lt;/a&gt;&lt;br /&gt; &lt;a href=&quot;#movie&quot;&gt;推荐电影&lt;/a&gt;&lt;br /&gt; &lt;/div&gt; ……&lt;br /&gt; ……&lt;br /&gt; ……&lt;br /&gt; ……&lt;br /&gt; ……&lt;br /&gt; ……&lt;br /&gt; ……&lt;br /&gt; ……&lt;br /&gt; &lt;div id=&quot;article&quot;&gt; &lt;h3&gt;推荐文章&lt;/h3&gt; &lt;ul&gt; &lt;li&gt;朱自清-荷塘月色&lt;/li&gt; &lt;li&gt;余光中-乡愁&lt;/li&gt; &lt;li&gt;鲁迅-阿Q正传&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; ……&lt;br /&gt; ……&lt;br /&gt; ……&lt;br /&gt; ……&lt;br /&gt; ……&lt;br /&gt; ……&lt;br /&gt; ……&lt;br /&gt; ……&lt;br /&gt; &lt;div id=&quot;music&quot;&gt; &lt;h3&gt;推荐音乐&lt;/h3&gt; &lt;ul&gt; &lt;li&gt;林俊杰-被风吹过的夏天&lt;/li&gt; &lt;li&gt;曲婉婷-在我的歌声里&lt;/li&gt; &lt;li&gt;许嵩-灰色头像&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; ……&lt;br /&gt; ……&lt;br /&gt; ……&lt;br /&gt; ……&lt;br /&gt; ……&lt;br /&gt; ……&lt;br /&gt; ……&lt;br /&gt; ……&lt;br /&gt; &lt;div id=&quot;movie&quot;&gt; &lt;h3&gt;推荐电影&lt;/h3&gt; &lt;ul&gt; &lt;li&gt;蜘蛛侠系列&lt;/li&gt; &lt;li&gt;钢铁侠系统&lt;/li&gt; &lt;li&gt;复仇者联盟&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 当点击“推荐文章”“推荐音乐”“推荐电影”这3个超链接后，页面就会自动滚动到相应的部分。仔细观察这个例子就可以知道，想要实现锚点链接，需要定义以下2个参数。 其中，id属性就是元素的名称，这个id名是随便起的（一般是英文）。不过在同一个页面中，id是唯一的，也就是说一个页面不允许出现相同的id。 最后要注意一点，a标签的href属性取值时，需要在id前面加上“#”（井号），以表示这是一个锚点链接。 HTML表单表单介绍表单标签：（5种） form、input、textarea、select和option 从外观上来划分，表单可以分为以下8种。 （1）单行文本框 （2）密码文本框 （3）单选框 （4）复选框 （5）按钮 （6）文件上传 （7）多行文本框 （8）下拉列表 form标签在HTML中，我们都知道表格的行（tr）、单元格（th、td）等都必须放在table标签内部。创建一个表单，跟创建一个表格一样，也必须要把所有表单标签放在form标签内部。 表单跟表格，这是两个完全不一样的概念。记住，常说的表单，指的是文本框、按钮、单选框、复选框、下拉列表等的统称。 语法： &lt;form&gt; //各种表单标签 &lt;/form&gt; 例： &lt;body&gt; &lt;form&gt; &lt;input type=&quot;text&quot; value=&quot;这是一个单行文本框&quot;/&gt;&lt;br/&gt; &lt;textarea&gt;这是一个多行文本框&lt;/textarea&gt;&lt;br/&gt; &lt;select&gt; &lt;option&gt;HTML&lt;/option&gt; &lt;option&gt;CSS&lt;/option&gt; &lt;option&gt;JavaScript&lt;/option&gt; &lt;/select&gt; &lt;/form&gt; &lt;/body&gt; form标签属性 属性 说明 name 表单名称 method 提交方式 action 提交地址 target 打开方式 enctype 编码方式 name属性： 在一个页面中，表单可能不止一个，每一个form标签就是一个表单。为了区分这些表单，可以使用name属性来给表单进行命名。 例： &lt;form name=&quot;myForm&quot;&gt;&lt;/form&gt; method属性： 在form标签中，method属性用于指定表单数据使用哪一种http提交方法。method属性取值有两个：一个是“get”，另外一个是“post”。 get的安全性较差，而post的安全性较好。所以在实际开发中，使用post比较多。 举例： &lt;form method=&quot;post&quot;&gt;&lt;/form&gt; action属性： 在form标签中，action属性用于指定表单数据提交到哪一个地址进行处理。 举例： &lt;form action=&quot;index.php&quot;&gt;&lt;/form&gt; target属性： form标签的target属性跟a标签的target属性是一样的，都是用来指定窗口的打开方式。一般情况下，只会用到“_blank”这一个属性值。 举例： &lt;form target=&quot;_blank&quot;&gt;&lt;/form&gt; enctype属性： 在form标签中，enctype属性用于指定表单数据提交的编码方式。一般情况下，不需要设置，除非用到上传文件功能。 input标签在HTML中，大多数表单都是使用input标签来实现的。 语法： &lt;input type=&quot;表单类型&quot; /&gt; input是自闭合标签，它是没有结束符号的。其中type属性取值： text-单行文本框 password-密码文本框 radio-单选框 checkbox-多选框 button/submit/reset-按钮file-文件上传 不同属性对应不同的效果。 input-text：单行文本框语法： &lt;input type=&quot;text&quot; /&gt; &lt;form method=&quot;post&quot;&gt; 姓名：&lt;input type=&quot;text&quot; /&gt; &lt;/form&gt; 单行文本框属性： 属性 说明 value 设置文本框的默认值，也就是默认情况下文本框 size 设置文本框的长度 maxlength 设置文本框中最多可以输入的字符数 value属性用于设置单行文本框中默认的文本，如果没有设置，就是空白。 size属性可以用来设置单行文本框的长度，不过在实际开发中，我们一般不会用到这个属性，而是使用CSS来控制。 外观上看不出maxlength加上与不加上有什么区别，不过当输入内容后，发现设置maxlength=”5”的单行文本框最多只能输入5个字符、 input-password密码文本框：密码文本框在外观上与单行文本框相似，两者拥有相同的属性（value、size、maxlength等）。不过它们是有着本质上的区别的：在单行文本框中输入的字符是可见的，而在密码文本框中输入的字符不可见。 语法： &lt;input type=&quot;password&quot; /&gt; &lt;form method=&quot;post&quot;&gt; 账号：&lt;input type=&quot;text&quot; /&gt;&lt;br /&gt; 密码：&lt;input type=&quot;password&quot; /&gt; &lt;/form&gt; 属性同上text单行文本框。 input-radio单选框：在HTML中，单选框也是使用input标签来实现的，其中type属性取值为“radio”。 语法： &lt;input type=&quot;radio&quot; name=&quot;组名&quot; value=&quot;取值&quot; /&gt; &lt;form method=&quot;post&quot;&gt; 性别: &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;男&quot; /&gt;男 &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;女&quot; /&gt;女 &lt;/form&gt; name属性表示单选按钮所在的组名，而value表示单选按钮的取值，这两个属性必须要设置。 checked属性： 在默认情况下，让第一个单选框选中，可以使用checked属性来实现。 可能看到checked属性没有属性值，这是HTML5的最新写法。下面两句代码其实是等价的，不过一般都是采用缩写形式。 &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;男&quot; checked /&gt;男 &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;女&quot; /&gt;女 &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;男&quot; checked /&gt;男 &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;男&quot; checked=&quot;checked&quot; /&gt;男 重点：name属性容易遗忘，若不添加name属性，或者同一组单选框选项的name不同，则可导致一组内的单选框都可被选中，所以name属性很重要。只有同一name下的一组数据才能使单选框选项互斥。 input-checkbox复选框：在HTML中，复选框也是使用input标签来实现的，其中type属性取值为“checkbox”。单选框只能选择一项，而复选框可以选择多项。 语法： &lt;input type=&quot;checkbox&quot; name=&quot;组名&quot; value=&quot;取值&quot; /&gt; &lt;form method=&quot;post&quot;&gt; 你喜欢的水果：&lt;br/&gt; &lt;input type=&quot;checkbox&quot; name=&quot;fruit&quot; value=&quot;苹果&quot;/&gt;苹果 &lt;input type=&quot;checkbox&quot; name=&quot;fruit&quot; value=&quot;香蕉&quot;/&gt;香蕉 &lt;input type=&quot;checkbox&quot; name=&quot;fruit&quot; value=&quot;西瓜&quot;/&gt;西瓜 &lt;input type=&quot;checkbox&quot; name=&quot;fruit&quot; value=&quot;李子&quot;/&gt;李子 &lt;/form&gt; name和value属性同上单选框，务必要设置。 input-button普通按钮在HTML中，普通按钮一般情况下都是配合JavaScript来进行各种操作的。 语法： &lt;input type=&quot;button&quot; value=&quot;取值&quot; /&gt; &lt;form method=&quot;post&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;起飞&quot;/&gt; &lt;/form&gt; value的取值就是按钮上的文字。 input-submit提交按钮在HTML中，提交按钮一般都是用来给服务器提交数据的。我们可以把提交按钮看成是一种特殊功能的普通按钮。 语法： &lt;input type=&quot;submit&quot; value=&quot;取值&quot;/&gt; 提交按钮只能提交它“所在form标签”内表单中的内容 input-reset重置按钮在HTML中，重置按钮一般用来清除用户在表单中输入的内容。重置按钮也可以看成是具有特殊功能的普通按钮。 语法： &lt;input type=&quot;reset&quot; value=&quot;取值&quot; /&gt; 重置按钮只能清空它“所在form标签”内表单中的内容，对于当前所在form标签之外的表单清除是无效的。 button标签普通按钮、提交按钮以及重置按钮这3种按钮都是使用input标签来实现的。其实还有一种按钮是使用button标签来实现的。 语法： &lt;button&gt;&lt;/button&gt; 在实际开发中，比较少用到button标签。 input-file文件上传文件上传功能的实现需要用到后端技术，文件上传功能经常用到。 在HTML中，文件上传也是使用input标签来实现的，其中type属性取值为file。 语法： &lt;input type=&quot;file&quot; /&gt; textarea标签：多行文本框单行文本框只能输入一行文本，而多行文本框却可以输入多行文本。在HTML中，多行文本框使用的是textarea标签，而不是input标签。 语法： &lt;textarea rows=&quot;行数&quot; cols=&quot;列数&quot; value=&quot;取值&quot;&gt;默认内容&lt;/textarea&gt; 多行文本框的默认显示文本是在标签对内部设置，而不是在value属性中设置的。一般情况下，不需要设置默认显示文本。 文本框总结对于文本框，现在我们可以总结出以下2点。 （1）HTML有3种文本框：单行文本框、密码文本框、多行文本框。 （2）单行文本框和密码文本框使用的都是input标签，多行文本框使用的是textarea标签。 select标签：下拉列表在HTML中，下拉列表由select和option这两个标签配合使用来表示的。这一点跟无序列表很像，其中无序列表是由ul和li这两个标签配合使用来表示。为了更好地理解，可以把下拉列表看成是一种“特殊的无序列表”。 语法： &lt;select&gt; &lt;option&gt;选项内容&lt;/option&gt; …… &lt;option&gt;选项内容&lt;/option&gt; &lt;/select&gt; select标签属性 属性 说明 multiple 设置下拉列表可以选择多项 size 设置下拉列表显示几个列表项，取值为整数 multiple属性： 下拉列表的multiple属性没有属性值，这是HTML5的最新写法。 默认情况下，下拉列表只能选择一项，我们可以通过multiple属性设置下拉列表可以选择多项。想要选取多项，可以使用“Ctrl+鼠标左键”来选取。 &lt;select multiple&gt; &lt;option&gt;HTML&lt;/option&gt; &lt;option&gt;CSS&lt;/option&gt; &lt;option&gt;jQuery&lt;/option&gt; &lt;option&gt;JavaScript&lt;/option&gt; &lt;option&gt;Vue.js&lt;/option&gt; &lt;option&gt;HTML5&lt;/option&gt; &lt;option&gt;CSS3&lt;/option&gt; &lt;/select&gt; size属性： 设置下拉列表显示几个列表项，取值为整数。 有些小伙伴将size取值为1、2、3时，会发现Chrome浏览器无效。这是因为Chrome浏览器最低是4个选项，我们只能选取4及以上数字。 &lt;select size=&quot;5&quot;&gt; &lt;option&gt;HTML&lt;/option&gt; &lt;option&gt;CSS&lt;/option&gt; &lt;/select&gt; option标签属性 属性 说明 selected 是否选中 value 选项值 selected属性： &lt;select size=&quot;5&quot;&gt; &lt;option&gt;HTML&lt;/option&gt; &lt;option&gt;CSS&lt;/option&gt; &lt;option selected&gt;jQuery&lt;/option&gt; &lt;/select&gt; selected属性表示列表项是否被选中，它是没有属性值的，这也是HTML5的最新写法，这个跟单选框中的checked属性也是一样的。 value属性： 对于value属性，不多说，几乎所有表单元素都有value属性，这个属性是配合JavaScript以及服务器进行操作的。 语法： &lt;select size=&quot;5&quot;&gt; &lt;option value=&quot;HTML&quot;&gt;HTML&lt;/option&gt; &lt;option value=&quot;CSS&quot;&gt;CSS&lt;/option&gt; &lt;/select&gt; 敲黑板：标签label语义化规范：为了更好地语义化，表单元素与后面的文本一般都需要借助label标签关联起来。 同时还能增加用户体验。 如：（除了选项同时也适用于文本框） &lt;label&gt;&lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;男&quot; /&gt;男&lt;/label&gt; &lt;label&gt;&lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;女&quot; /&gt;女&lt;/label&gt; 表单注意事项：1、表单元素那么多，而且每一种自己还有好几个属性，应该怎么记忆呢？ 对于初学者来说，表单记忆是最关心也是最为头疼的一件事。在HTML入门时，我们不需要花太多时间去记忆这些标签或属性，只需要感性认知即可。忘了的时候，就回来翻一下。此外，编辑器一般也会有代码提示，写多了自然就会记住了。 2、表单元素是否一定要放在form标签内呢？ 表单元素不一定都要放在form标签内。对于要与服务器进行交互的表单元素就必须放在form标签内才有效。如果表单元素不需要跟服务器进行交互，那就没必要放在form标签内。 HTML框架iframe标签在HTML中，我们可以使用iframe标签来实现一个内嵌框架。内嵌框架，说白了，就是在当前页面再嵌入另外一个网页。 语法： &lt;iframe src=&quot;链接地址&quot; width=&quot;数值&quot; height=&quot;数值&quot;&gt;&lt;/iframe&gt; src是必选的，用于定义链接页面的地址。width和height这两个属性是可选的，分别用于定义框架的宽度和高度。 iframe实际上就是在当前页面嵌入了另外一个页面，我们也可以同时嵌入多个页面。 &lt;body&gt; &lt;iframe src=&quot;http://nanivy.space&quot; width=&quot;200&quot; height=&quot;150&quot;&gt;&lt;/iframe&gt; &lt;/body&gt; 还有什么frameset、frame标签，事实上这几个标签在HTML5标准中已经被废弃了。对于框架，我们只需要掌握iframe这一个标签就可以了。","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"学习","slug":"学习","permalink":"/tags/学习/"},{"name":"HTML","slug":"HTML","permalink":"/tags/HTML/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"近期自我总结21.6","slug":"近期自我总结21.6","date":"2021-06-29T07:10:02.000Z","updated":"2021-09-12T14:11:53.151Z","comments":true,"path":"2021/06/29/近期自我总结21.6/","link":"","permalink":"/2021/06/29/近期自我总结21.6/","excerpt":"","text":"近期总结​ 最近自己也摸鱼完一段时间了，总结自己走过来的学安全的日子，过的浑浑噩噩，难以形容。可惜浪费的时间。 ​ 但是，自己也确实该真正去尝试去做点事情了。大学时光成功鬼混一年了，什么都没学会，安全连皮毛都没学进去。静下心想想，自己果然更喜欢创造一些东西 ，或者说一种动手能力。从小我就喜欢拆家里的电器，钟表等等各种能用电的东西，说不定我还蛮适合去搞硬件？（做梦） ​ 去了解了一些东西——发现了web前端。其实给我第一印象并不好，不就是记标签，然后用标签还原网页吗？再仔细了解，其实这东西还挺有趣的？绝对不是想象中的那么简单。或许我愿意去试试。 新一年的目标​ 所以，接下来的一年，我打算好好学习web前端。 ​ 给自己定下一个小目标——学好web前端，自己写一个不错的小（静态）网站，做自己喜欢的东西，说不定我也要去兽耳科技，为爱，付出。有了追求，有了理想，接下来的我，便是努力了吧。未来还长，我愿意为之付出，加油吧，我这样的废物。 ​ 纸片人老婆们，请期待我吧，我会努力的。 ​ 淡淡无名，月下起舞。","categories":[{"name":"随想","slug":"随想","permalink":"/categories/随想/"}],"tags":[{"name":"悦读","slug":"悦读","permalink":"/tags/悦读/"},{"name":"随想","slug":"随想","permalink":"/tags/随想/"}],"keywords":[{"name":"随想","slug":"随想","permalink":"/categories/随想/"}]},{"title":"web学习笔记——CSRF","slug":"web学习笔记——CSRF","date":"2021-02-25T06:22:33.000Z","updated":"2021-07-12T07:40:16.636Z","comments":true,"path":"2021/02/25/web学习笔记——CSRF/","link":"","permalink":"/2021/02/25/web学习笔记——CSRF/","excerpt":"","text":"CSRF介绍、概念CSRF跨站点请求伪造(Cross—Site Request Forgery)，也被称为 one-click attack 或者 session riding，通常缩写为 CSRF 或者 XSRF， 是一种挟制用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法。跟跨网站脚本（XSS）相比，XSS利用的是用户对指定网站的信任，CSRF 利用的是网站对用户网页浏览器的信任。 简单理解： 攻击者盗用了你的身份，以你的名义发送恶意请求，对服务器来说这个请求是完全合法的，但是却完成了攻击者所期望的一个操作，比如以你的名义发送邮件、发消息，盗取你的账号，添加系统管理员，甚至于购买商品、虚拟货币转账等。 如下：其中Web A为存在CSRF漏洞的网站，Web B为攻击者构建的恶意网站，User C为Web A网站的合法用户。 攻击原理： 用户C打开浏览器，访问受信任网站A，输入用户名和密码请求登录网站A； ​ 2.在用户信息通过验证后，网站A产生Cookie信息并返回给浏览器，此时用户登录网站A成功，可以正常发送请求到网站A； ​ 3. 用户未退出网站A之前，在同一浏览器中，打开一个TAB页访问网站B； ​ 4. 网站B接收到用户请求后，返回一些攻击性代码，并发出一个请求要求访问第三方站点A； 5. 浏览器在接收到这些攻击性代码后，根据网站B的请求，在用户不知情的情况下携带Cookie信息，向网站A发出请求。网站A并不知道该请求其实是由B发起的，所以会根据用户C的Cookie信息以C的权限处理该请求，导致来自网站B的恶意代码被执行。 受害者只需要做下面两件事情，攻击者就能够完成CSRF攻击： 登录受信任站点 A，并在本地生成cookie； 在不登出站点A（清除站点A的cookie）的情况下，访问恶意站点B。 CSRF攻击举例GET型假设某银行网站A以GET请求来发起转账操作，转账的地址为www.xxx.com/transfer.do?accountNum=l000l&amp;money=10000，参数accountNum表示转账的账户，参数money表示转账金额。 而某大型论坛B上，一个恶意用户上传了一张图片，而图片的地址栏中填的并不是图片的地址，而是前而所说的砖账地址：&lt;img src=&quot;http://www.xxx.com/transfer.do?accountNum=l000l&amp;money=10000&quot;&gt; 当你登录网站A后，没有及时登出，这时你访问了论坛B，不幸的事情发生了，你会发现你的账号里面少了10000块… 为什么会这样呢，在你登录银行A时，你的浏览器端会生成银行A的cookie，而当你访问论坛B的时候，页面上的标签需要浏览器发起一个新的HTTP请求，以获得图片资源，当浏览器发起请求时，请求的却是银行A的转账地址www.xxx.com/transfer.do?accountNum=l000l&amp;money=10000，并且会带上银行A的cookie信息，结果银行的服务器收到这个请求后，会以为是你发起的一次转账操作，因此你的账号里边便少了10000块。 当然，绝大多数网站都不会使用GET请求来进行数据更新，因此，攻击者也需要改变思路，与时俱进。 POST型假设银行将其转账方式改成POST提交，而论坛B恰好又存在一个XSS漏洞，恶意用户在它的页面上植入如下代码： &lt;form id=&quot;aaa&quot; action=&quot;http://www.xxx.com/transfer.do&quot; metdod=&quot;POST&quot; display=&quot;none&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;accountNum&quot; value=&quot;10001&quot;/&gt; &lt;input ty。pe=&quot;text&quot; name=&quot;money&quot; value=&quot;10000&quot;/&gt; &lt;/form&gt; &lt;script&gt; var form = document.forms(&#39;aaa&#39;); form.submit(); &lt;/script&gt; 如果你此时恰好登录了银行A，且没有登出，当你打开上述页面后，脚本会将表单aaa提交，把accountNum和money参数传递给银行的转账地址http://www.xxx.com/transfer.do，同样的，银行以为是你发起的一次转账会从你的账户中扣除10000块。 CSRF防御1、尽量使用POST，限制GET GET接口太容易被拿来做CSRF攻击，看上面示例就知道，只要构造一个img标签，而img标签又是不能过滤的数据。接口最好限制为POST使用，GET则无效，降低攻击风险。 当然POST并不是万无一失，攻击者只要构造一个form就可以，但需要在第三方页面做，这样就增加暴露的可能性。 2、增加token类似一种不需要输入的“验证码”。 CSRF攻击之所以能够成功，是因为攻击者可以伪造用户的请求，该请求中所有的用户验证信息都存在于cookie中，因此攻击者可以在不知道用户验证信息的情况下直接利用用户的cookie来通过安全验证。由此可知，抵御CSRF攻击的关键在于：在请求中放入攻击者所不能伪造的信息，并且该信息总不存在于cookie之中。鉴于此，系统开发人员可以在HTTP请求中以参数的形式加入一个随机产生的token，并在服务端进行token校验，如果请求中没有token或者token内容不正确，则认为是CSRF攻击而拒绝该请求。也可以在HTML表单中加入隐藏的token，在提交表单时验证（适用范围小） 但如果网站同时存在xss、csrf，这种token防御机制可能就失效了，因为攻击者能从javascript获取token值。 3、二次确认在用户进行一些关键操作时候，产生对话框二次提示确认。 或要求输入验证码，敏感操作要进行验证码验证。 这样用户突然收到提示也会警觉起来。 参考： https://blog.csdn.net/stpeace/article/details/53512283 https://www.jianshu.com/p/67408d73c66d https://www.cnblogs.com/hyddd/archive/2009/04/09/1432744.html","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"CSRF漏洞","slug":"CSRF漏洞","permalink":"/tags/CSRF漏洞/"},{"name":"学习","slug":"学习","permalink":"/tags/学习/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"web学习笔记——http请求响应","slug":"web学习笔记——http请求响应","date":"2021-02-09T15:21:19.000Z","updated":"2021-07-16T01:12:47.678Z","comments":true,"path":"2021/02/09/web学习笔记——http请求响应/","link":"","permalink":"/2021/02/09/web学习笔记——http请求响应/","excerpt":"","text":"总结不出什么东西，直接转载大佬的 请求头User-Agent:例：User-Agent:Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.186 Safari/537.36表示客户端的软件环境。如上可以看出使用的是Window10 64位操作系统，Chrome浏览器等信息。服务器可以根据该字段评估客户端的环境从而给出不同的响应。（比如根据请求是从手机端或是电脑端发起的，返回不同版本的页面） Host：例：Host:localhost:8080表示请求者的主机地址（IP地址）和端口号。服务器端可以根据该字段进行ip过滤等操作。 Accept：例：Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,/;q=0.8表示客户端支持的数据格式，或者说客户端“希望”接受到的内容类型。这里只是希望，但是服务器具体返回什么样的内容类型，还是由服务器自己决定，但是无论服务器返回什么样的内容类型，客户端都会接收响应报文，不可能说因为内容类型不同，接收不到服务器响应报文，这不符合http协议规范。 我们通过浏览器发起get或post请求，该字段都是浏览器自动添加的，同样在服务器端也不会解析该字段的值；通过ajax请求或其他手段，我们可以设置该字段的值，但是通常也不进行设置。 该字段的应用场景可以是这样的，有两个终端，比如一个是纯文本阅读器，如Kinder（不能显示图片），另一个是移动终端（可以播放图片和视频），均向服务器请求有关“斑马”的信息，那么这时候服务器端就需要判断什么样的终端应该返回什么样的信息，那么它就可以根据Accept的信息来进行判断，如果解析到的Accept的值为“text/plain”，那么就表示客户端只支持文本类型；如果向上面例子中的那样，则表示客户端文本图片视频都可以。如果我们不加判断，当返回给文本阅读器一张图片时，可能它显示的就是乱码。 Accept-Encoding:例：Accept-Encoding:gzip, deflate, br表示客户端所支持的解码（解压缩）格式。 网路数据的传输都是占据带宽的，而将文件数据压缩能够降低数据量，减少传输时间。所以服务器在返回数据给客户端时，常常对数据进行压缩（对用户透明，通常由服务器或代理来做），而压缩的方式有多种，到底采用哪一种则需要看客户端支持哪种解码方式，这时候就可以根据header中Accept-Encoding的值。 文件或数据的压缩，由服务器或代理来做，一般不需要程序员干预；客户端接收到数据时解压缩，通常由浏览器自动完成，对用户透明。对于我们主动发起的ajax请求，一般数据量较少，不需要设置该字段。 Accept-Language:例Accept-Language:zh-CN,zh;q=0.9表示客户端支持的语言格式（不是编码格式），如中文/英文，通常浏览器直接发起请求时，浏览器会根据被设置的语言环境（默认语言），来附加上该字段。 一般我们服务器解析报文时，是不理会该字段的。他的使用场景可以是这样的，假如有个文件，有各种语言的版本，这样当不同请求发来时，我们可以根据Accept-Language的值来判断到底返回哪种语言版本给客户端。（其实这种应用场景也一般不采用判断Accept-Language字段的方法，不靠谱，还不如直接在url中体现语言版本呢） Accept-Charset：例：Accept-Charset:gbk,utf-8;q=0.8表示客户端支持编码格式。服务器在返回报文时，需要将字符按照一定的编码格式转换为字节序列发送给客户端，那么该采用哪种编码格式呢？当然作为服务器端，他可以采用任何一种编码方式，客户端都得完完整整的接收响应报文。因为目前客户端几乎都支持常见编码类型，所以服务器在返回数据时，只需要按照既定的编码方式编码，然后在响应报文中告知客户端所使用的编码方式。这样客户端在接收到报文后按照该方式进行解码，就就不会出现乱码问题。 但是，如果客户端已经定了就使用某种解码方式，那么这时候服务器端就不能那么任性了，他就需要解析Accept-Charset字段，根据这个值，来设定采用的编码方式。如上例中，以逗号分隔，客户端支持两种编码方式，gbk和utf-8（gbk优先级高于utf8），其中utf-8后的q值，表示utf-8占的“权重”。 Referer：例：Referer:http://localhost:8080/test/11.html表示当前请求是从哪个资源发起的；或者是请求的上一步的地址。 Cookie： cookie是非常重要的请求头，他是一段文本，常用来表示请求者身份等。 XFF（X-Forward-For）：它代表请求端的ip，可以有多个，中间以逗号隔开。 If-Modified-Since：例：If-Modified-Since:Thu, 29 Mar 2018 08:37:45 GMT表示客户端缓存文件的时间。字面翻译的意思是，“如果从…时间改变了”（就请再发送给我一遍新的文件）。 当客户端访问服务器的静态文件时，通常会将资源结果缓存下来，并标记一下文件的缓存时间（根据响应头中的Last-Modified字段）；当接下来再发送同样的请求时，会在请求头中添加上这个字段If-Modified-Since； 服务器端读取字段值，判断服务器端文件的最后修改时间，如果如果不晚于该值，说明浏览器缓存的文件是最新的，然后就不会重新发送文件内容，而是将相应报文的状态设置为304，表示你读取缓存的文件就可以了，这就很大程度上节省了带宽。 If-None-Match:例：If-None-Match:W/”607-1522312665174”该字段同If-Modified-Since字段一样，都是用来表示资源文件是否是最新的。只不过If-Modified-Since的值为文件的最后修改时间，而该值为资源实体的哈希值，同样是由服务器生成的。从上面的截图中我们可以看到：第一次请求时，服务器的响应报文中有字段Etag，这就是实体的哈希值，浏览器会缓存文件并记录该值。第二次请求时，请求头字段中就有If-None-Match，值为Etag的值，而服务器会判断该值与服务器中文件的哈希值是否相同，如果相同，就返回304，让浏览器读取缓存；否则会返回新的资源文件，并在响应头中设置新的Etag值。 Last-Modified/If-Modified-Since 和 Etag/If-None-Match这两对头字段都是来标记缓存资源的，但是后者的优先级要高于前者。 Cache-Control:（了解为主）例： Cache-Control:no-cache字段的字面意思为“缓存-控制”，前面我们将了几个字段表面客户端/服务器如何使用缓存机制，而这个字段就是用来控制缓存的。 Cache-Control在请求/响应报文头中均可设置，分别表明不同的意思，下面我们以响应报文为例：cache-control在响应报文的的取值可以为：public、private、no-cache、no- store、no-transform、must-revalidate、proxy-revalidate、max-age。 其中，no-cache、no-store、max-age为常用的取值。比如，服务器在响应报文中添加Cache-Control：no-store，表示浏览器或各级代理，不要缓存本次的相应内容（即使响应报文中有Etag和Last-Modified）; 比如，响应报文中有Cache-Control：no-cache，表示浏览器可以缓存响应文件，但是在使用缓存之前，必须通过令牌（Etag）来与服务器进行沟通确认缓存有效。 比如，响应报文中有Cache-Control：max-age=500，表示在接下来的500秒内，浏览器可以自主使用缓存内容，不需要向服务器发送同样的请求。 在请求报文中，也可以添加cache-control字段，其取值可以为no-cache、no-store、max-age、 max-stale、min-fresh、only-if-cached。客户端在发送请求到服务器时，可能会经过很多层代理，而这些代理可能就缓存了本次请求想要的文件，而请求中的cache-control就可以控制，是否使用代理中的缓存文件。 比如，请求报文头中有cache-control：no-cache，那就表示，代理如果返回给我缓存文件时，需要到服务器端进行确认，缓存是不是最新的。 比如，请求报文头中有cache-control：no-store，那就表示，我不需要代理中的缓存文件，我需要直接请求服务器。 所以我们可以看到，cache-control就是用来控制缓存使用的，如是否缓存，是否使用缓存，缓存到期时间等，而Last-Modified/If-Modified-Since 和 Etag/If-None-Match是标识C/S之间怎么使用缓存。缓存的使用都是服务器和客户端的默认行为，对用户和程序员的透明的，当然我们可以通过配置文件或程序修改他们的行为规则。附：http协议中对缓存的说明 响应头Etag、Last-Modified（资源最后修改时间）、cache-control在前文中已经说明。 Content-Length:例：Content-Length:607表示接收到的响应报文的总长度为607。根据这个长度，客户端可以更准确的接收和解析报文内容。或者可以根据当前接收/解析的长度占总长度的百分比，做出进度条的效果。 Accept-Ranges:例：Accept-Ranges:bytes表示服务器支持http中的Range功能，能够分段请求客户端能够分段请求服务器。我们上网时常用的“断点续传”，或者服务器所谓的“多线程下载”就是靠的服务器端的Range技术。 Range功能的请求-响应流程如此：客户端发起带range的请求： GET /test.rar HTTP/1.1 Connection: close Host: 116.1.219.219 Range: bytes=0-100 在头中添加Range字段，表示我要请求[0-100]这101个字节的数据。此处Range的值，可以添加多个片段，如 Range：bytes=0-100,200-300等。 服务器响应报文： HTTP/1.1 206 OK Content-Length: 801 Content-Type: application/octet-stream Content-Location: http://www.onlinedown.net/hj_index.htm Content-Range: bytes 0-100/2350 //2350:文件总大小 Last-Modified: Mon, 16 Feb 2009 16:10:12 GMT Accept-Ranges: bytes ETag: &quot;d67a4bc5190c91:512&quot; Date: Wed, 18 Feb 2009 07:55:26 GMT 响应报文中有Content-Range字段，表示响应的报文片段内容范围，已经总的数据大小。同时Range请求的正常的返回码是206，不是200。 而即使我们请求的不是Range功能请求，那么服务器的返回字段中会有Accept-Range，表示服务器支持Range功能。 Server:例：Server: Apache/2.4.1 (Unix)表示服务器的名称，是Unix下的Apache服务器 Set-Cookie：向客户端设置cookie，通过查看此头，可以清楚看到服务器向客户端发送的cookie信息。 Location服务器通过通过这个头告诉浏览器去访问那个页面，浏览器收到这个请求之后，通常会立刻访问location头所指向的页面。这个头通常配合302状态码使用。 Refresh：服务器通过该头告诉浏览器定时刷新浏览器。 转载 Boboma_dut 的CSDN 博客 ，全文地址请点击：https://blog.csdn.net/Boboma_dut/article/details/79741162?utm_source=copy","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"学习","slug":"学习","permalink":"/tags/学习/"},{"name":"HTTP","slug":"HTTP","permalink":"/tags/HTTP/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"web学习笔记——文件上传","slug":"web学习笔记——文件上传","date":"2021-01-29T00:29:22.000Z","updated":"2021-07-16T02:00:46.305Z","comments":true,"path":"2021/01/29/web学习笔记——文件上传/","link":"","permalink":"/2021/01/29/web学习笔记——文件上传/","excerpt":"","text":"文件上传漏洞总结常见工具：BurpSuite、蚁剑。 原理及利用为什么会有文件上传漏洞，字面意思文件上传的漏洞。在一些上传文件的入口，面对上传文件，若不对上传文件进行严格的验证和过滤就容易造成这漏洞的产生。即可能上传任何文件——包括病毒、脚本。 上传正常的php对服务器没有什么危害，但总有离谱的——如：PHP是编程语言，可以查看目录下的文件，查看文件中的代码，还能执行系统命令。上传恶意的PHP文件，甚至还能控制整个网站文件甚至是服务器。 或者有上传钓鱼图片的，flash的策略文件.xml的。 不过一般情况下的利用，指的应该就是“上传web脚本”并让服务器解析吧。即webshell攻击。成功的条件也是有的：能上传，能调用，能被执行，不被安全检查（想办法绕过）或格式化或者图片马被压缩（可能会导致内容改变而影响功能）。 常见绕过总结客户端校验通过javascript来校验上传文件的后缀是否合法，可以采用白名单，也可以采用黑名单的方式判断方式：在浏览加载文件，但还未点击上传按钮时便弹出对话框，内容如：只允许上传.jpg/.jpeg/.png后缀名的文件，而此时并没有发送数据包。客户端校验绕过：直接修改js代码（一些浏览器自带选项貌似有禁用js选项）或者使用抓包的方法修改请求内容绕过，可以先上传一个gif木马，通过抓包修改为 jsp/php/asp，只用这种方法来检测是肯定可以绕过的。 服务器端校验校验请求头 content-type字段，例如用PHP检测 if($_FILES[‘userfile’][‘type’] != “image/gif”){ ….}通过自己写正则匹配来判断文件幻数(文件头)内容是否符合要求，一般来说属于白名单的检测，常见的文件头（文件头标志位）如下：括号中对应的二进制代码（1）.JPEG;.JPE;.JPG，”JPGGraphicFile”（FFD8FFFE00）（2）.gif，”GIF89A”（474946383961）（3）.zip，”ZipCompressed”（504B0304）（4）.doc;.xls;.xlt;.ppt;.apr，”MSCompoundDocumentv1orLotusApproachAPRfile”（D0CF11E0A1B11AE1）还有其他的文件头可自行资料查找。 服务端绕过校验请求头content-type字段绕过 通过抓包来修改Http头的content-type即可绕过，也肯定是可以绕过这种检测 POST /upload.php HTTP/1.1TE: deflate,gzip;q=0.3Connection: TE, closeHost: localhostUser-Agent: libwww-perl/5.803Content-Type: multipart/form-data; boundary=xYzZYContent-Length: 155–666666666666666666666666-Content-Disposition: form-data; name=”userfile”; filename=”shell.php”Content-Type: image/gif (原为 Content-Type: text/plain)&lt;?php system($_GET[‘command’]);?&gt;–6666666666666666666666666- 文件幻数(文件头)检测绕过： 在木马内容的前面插入对应的文件头内容，例如：GIF89a ，更靠谱的方法是在可上传的文件中插入木马代码，然后修改后缀 文件加载检测：一般是调用API或函数去进行文件加载测试，例如图像渲染测试，当测试结果正常的时候才允许上传 1、一次渲染（代码注入）2、二次渲染 文件加载检绕过通过例如加载文件进行图像渲染的方式来测试，这个时候就一般需要在正常的文件中插入木马代码了，例如图像，那么插入的代码一般会放在图像的注释区，因此不会影响图像正常渲染绕过这种检测，此时可以使用工具（称为插马器）来进行插入，例如edjpgcom，或者直接用copy命令来合成也可以。当然这种检测不一定能够完全绕过 后缀名黑名单校验、后缀名白名单校验：后缀名检测 后缀黑名单检测绕过：找查blacklist(黑名单列表)的漏网之鱼，例如大小写：如果检测的时候不忽略大小写，那么可以改变后缀名的大小写绕过扩展名：黑名单中如果忽略了某些能被解析的文件扩展名： jsp jspx jspf asp asa cer aspx php php php3 php4 pht php5 exe exee 后缀白名单检测绕过：白名单检测还是会比黑名单强一点，常见的绕过方法有%00截断，还有服务器的解析漏洞%00截断漏洞：如果存在这类漏洞，那么后缀名的检测都可以绕过，此时我们可以如下命名一个上传文件 test.php%00.jpg 操作系统相关绕过：上传不符合windows文件命名规则的文件名 test.asp.（windows的结尾默认不为为.会自动消掉这个点）test.asp(空格)test.php:1.jpgtest.php::$DATAshell.php::$DATA…….会被某些版本的windows系统自动去掉不符合规则符号后面的内容。 linux下后缀名大小写：linux是大小写敏感的，因此一般检测也会区分大小写，但某些解析器是不区分大小写的，例如PHP，上传php不被解析，可以试试上传pHp后缀的文件名。 竞争条件攻击：一些网站上传文件逻辑上是允许上传任意文件的，然后检查上传文件的内容是否包含webshell脚本，如果包含则删除该文件，这里存在的问题是文件上传成功之后和删除文件之间存在一个短的时间差，攻击者就可以利用这个时间差来上传漏洞攻击。攻击者先上传一个webshell脚本1.php内容如下： &lt;?php fputs(fopen(‘../shell.php’,’w’),’&lt;?php @eval($_POST[a]) ?&gt;’); ?&gt;代码内容就是生成一个新的webshell，shell.php，那么当1.php上传成功之后，我们快速访问这个文件，这时就会在服务器端当前目录下自动生成shell.php，这时就利用时间差完成了webshell的上传。 CMS、编辑器漏洞CMS漏洞： 可以针对不同CMS存在的上传漏洞进行绕过。编辑器漏洞：比如FCK，ewebeditor等，可以针对编辑器的漏洞进行绕过。参考链接：https://www.leavesongs.com/PENETRATION/UseOfFckeditor.htmlhttps://docs.google.com/document/d/1w_61xR8U7nmn4Y0CvBHpG1uFIU2ORx69QnqTxQt8Km0/edit?pli=1 WAF校验：即使用不同的WAF产品来进行过滤，通常是独立与服务程序的一段中间程序或者硬件 WAF绕过：参考链接：https://www.freebuf.com/articles/web/160175.html 解析漏洞：这类漏洞是本身服务器的中间件产生的，例如apache，nginx都被爆出过存在解析漏洞，存在解析漏洞的话，上传的安全性几乎就完全失去了，下面再详细分析。 服务器解析漏洞 IS5.x-6.x解析漏洞使用iis5.x-6.x版本的服务器，大多为windows server 2003，网站比较古老，开发语句一般为asp；该解析漏洞也只能解析asp文件，而不能解析aspx文件。 目录解析(6.0)形式：www.xxx.com/xx.asp/xx.jpg 原理: 服务器默认会把.asp，.asp目录下的文件都解析成asp文件。 文件解析形式：www.xxx.com/xx.asp;.jpg 原理：服务器默认不解析;号后面的内容，因此xx.asp;.jpg便被解析成asp文件了。 解析文件类型 IIS6.0 默认的可执行文件除了asp还包含这三种 :/test.asa/test.cer/test.cdx apache解析漏洞漏洞原理 Apache 解析文件的规则是从右到左开始判断解析,如果后缀名为不可识别文件解析,就再往左判断。比如 test.php.qwe.asd “.qwe”和”.asd” 这两种后缀是apache不可识别解析,apache就会把wooyun.php.qwe.asd解析成php。 漏洞形式 www.xxxx.xxx.com/test.php.php123其余配置问题导致漏洞 如果在 Apache 的 conf 里有这样一行配置 AddHandler php5-script .php 这时只要文件名里包含.php 即使文件名是 test2.php.jpg 也会以 php 来执行。 如果在 Apache 的 conf 里有这样一行配置 AddType application/x-httpd-php .jpg 即使扩展名是 jpg，一样能以 php 方式执行。 nginx解析漏洞漏洞原理 Nginx默认是以CGI的方式支持PHP解析的，普遍的做法是在Nginx配置文件中通过正则匹配设置 SCRIPT_FILENAME。当访问 www.xx.com/phpinfo.jpg/1.php这个URL时， $fastcgi_script_name会被设置为 “phpinfo.jpg/1.php”，然后构造成 SCRIPT_FILENAME传递给PHP CGI，但是PHP为什么会接受这样的参数，并将phpinfo.jpg作为PHP文件解析呢?这就要说到fix_pathinfo这个选项了。 如果开启了这个选项，那么就会触发在PHP中的如下逻辑： PHP会认为SCRIPTFILENAME是phpinfo.jpg，而1.php是PATHINFO，所以就会将phpinfo.jpg作为PHP文件来解析了 漏洞形式 www.xxxx.com/UploadFiles/image/1.jpg/1.phpwww.xxxx.com/UploadFiles/image/1.jpg %00.phpwww.xxxx.com/UploadFiles/image/1.jpg/ %20.php 另外一种手法：上传一个名字为test.jpg，然后访问test.jpg/.php,在这个目录下就会生成一句话木马shell.php。 IIS7.5解析漏洞 IIS7.5的漏洞与nginx的类似，都是由于php配置文件中，开启了 cgi.fix_pathinfo，而这并不是nginx或者iis7.5本身的漏洞。 参考文章 https://www.secpulse.com/archives/95987.htmlhttps://blog.csdn.net/weixin_44119101/article/details/107669831","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"学习","slug":"学习","permalink":"/tags/学习/"},{"name":"文件上传漏洞","slug":"文件上传漏洞","permalink":"/tags/文件上传漏洞/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"web学习笔记——SQL注入","slug":"web学习笔记——SQL注入","date":"2021-01-03T02:57:32.000Z","updated":"2021-07-12T07:40:24.651Z","comments":true,"path":"2021/01/03/web学习笔记——SQL注入/","link":"","permalink":"/2021/01/03/web学习笔记——SQL注入/","excerpt":"","text":"SQL产生原理​ 所谓SQL注入，就是通过把SQL命令插入到Web表单递交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。当应用程序使用输入内容来构造动态sql语句以访问数据库时，会发生sql注入攻击。如果代码使用存储过程，而这些存储过程作为包含未筛选的用户输入的字符串来传递，也会发生sql注入。 黑客通过SQL注入攻击可以拿到网站数据库的访问权限，之后他们就可以拿到网站数据库中所有的数据，恶意的黑客可以通过SQL注入功能篡改数据库中的数据甚至会把数据库中的数据毁坏掉 ​ 通过构建特殊的输入作为参数传入Web应用程序，而这些输入大都是SQL语法里的一些组合，通过执行SQL语句进而执行攻击者所要的操作，其主要原因是程序没有细致地过滤用户输入的数据，致使非法数据侵入系统。 ​ 根据相关技术原理，SQL注入可以分为平台层注入和代码层注入。前者由不安全的数据库配置或数据库平台的漏洞所致；后者主要是由于程序员对输入未进行细致地过滤，从而执行了非法的数据查询。基于此，SQL注入的产生原因通常表现在以下几方面：①不当的类型处理；②不安全的数据库配置；③不合理的查询集处理；④不当的错误处理；⑤转义字符处理不合适；⑥多个提交处理不当。 SQL注入方法理解1.数字注入 在浏览器地址栏输入：learn.me/sql/article.php?id=1，这是一个get型接口，发送这个请求相当于调用一个查询语句： $sql = &quot;SELECT * FROM article WHERE id =&quot;,$id 正常情况下，应该返回一个id=1的文章信息。那么，如果在浏览器地址栏输入：learn.me/sql/article.php?id=-1 OR 1 =1，这就是一个SQL注入攻击了，可能会返回所有文章的相关信息。为什么会这样呢？ 这是因为，id = -1永远是false，1=1永远是true，所有整个where语句永远是ture，所以where条件相当于没有加where条件，那么查询的结果相当于整张表的内容。（危） 2.字符串注入 有这样一个用户登录场景：登录界面包括用户名和密码输入框，以及提交按钮。输入用户名和密码，提交。 这是一个post请求，登录时调用接口learn.me/sql/login.html，首先连接数据库，然后后台对post请求参数中携带的用户名、密码进行参数校验，即sql的查询过程。假设正确的用户名和密码为user和pwd123，输入正确的用户名和密码、提交，相当于调用了以下的SQL语句： SELECT * FROM user WHERE username = &#39;user&#39; ADN password = &#39;pwd123&#39; ​ 由于用户名和密码都是字符串，SQL注入方法即把参数携带的数据变成mysql中注释的字符串。mysql中有2种注释的方法： （1）’#’：’#’后所有的字符串都会被当成注释来处理 用户名输入：user’#（单引号闭合user左边的单引号），密码随意输入，如：111，然后点击提交按钮。等价于SQL语句： SELECT * FROM user WHERE username = &#39;user&#39;#&#39;ADN password = &#39;111&#39; ‘#’后面都被注释掉了，相当于： SELECT * FROM user WHERE username = &#39;user&#39; （2）’– ‘ （–后面有个空格）：’– ‘后面的字符串都会被当成注释来处理 用户名输入：user’– （注意–后面有个空格，单引号闭合user左边的单引号），密码随意输入，如：111，然后点击提交按钮。等价于SQL语句： SELECT * FROM user WHERE username = &#39;user&#39;-- &#39;AND password = &#39;111&#39; SELECT * FROM user WHERE username = ‘user’– ‘AND password = ‘1111’ ‘– ‘后面都被注释掉了，相当于： SELECT * FROM user WHERE username = &#39;user&#39; 因此，以上两种情况可能输入一个错误的密码或者不输入密码就可登录用户名为’user’的账号，这是十分危险的事情。 SQL注入点判断分类 1、常见的sql注入按照参数类型可分为两种：数字型和字符型。 当发生注入点的参数为整数时，比如 ID，num，page等，这种形式的就属于数字型注入漏洞。同样，当注入点是字符串时，则称为字符型注入，字符型注入需要引号来闭合。 2、也可以根据数据库返回的结果，分为回显注入、报错注入、盲注。 回显注入：可以直接在存在注入点的当前页面中获取返回结果。 报错注入：程序将数据库的返回错误信息直接显示在页面中，虽然没有返回数据库的查询结果，但是可以构造一些报错语句从错误信息中获取想要的结果。 盲注：程序后端屏蔽了数据库的错误信息，没有直接显示结果也没有报错信息，只能通过数据库的逻辑和延时函数来判断注入的结果。根据表现形式的不同，盲注又分为based boolean和based time两种类型。 3、按照注入位置及方式不同分为：post注入，get注入，cookie注入，盲注，延时注入，搜索注入，base64注入，无论此种分类如何多，都可以归纳为以上两种形式。 判断 GET注入1、数字型：猜测SQL语句： select 字段名 from 表名 where id = 1； http://www.sql.com/xxx.php?id=1 假设ID为存在注入的参数 http://www.sql.com/xxx.php?id=1‘ 语句报错 http://www.sql.com/xxx.php?id=1 and 1=1 页面正常返回结果 http://www.sql.com/xxx.php?id=1 and 1=2 页面返回错误 1234 如果以上几个测试步骤结果全部满足，就可能存在sql注入漏洞。 数字型注入一般出现在asp，php等弱类型语言中，弱类型语言会自动推导变量类型，例如，参数id=1，PHP会自动把ID的数据类型推导为int类型，若是 id=1 and 1=1，则把ID推导为string类型。但是对于Java、c#这类强类型语言，如果把一个字符串转换为int类型，则会抛出异常，无法运行，所以数字型注入一般出现在弱类型的语言当中，强类型语言很少存在。 2、字符型：猜测SQL语句： select 字段名 from 表名 where id =‘； http://www.sql.com/xxx.php?id=1 假设ID为存在注入的参数 http://www.sql.com/xxx.php?id=1‘ 语句报错 http://www.sql.com/xxx.php?id=1&#39; and 1=1 and &#39;1&#39;=&#39;1 页面正常返回结果 http://www.sql.com/xxx.php?id=1&#39; and 1=2 and &#39;1&#39;=&#39;1 页面返回错误 1234 3、搜索型：猜测SQL语句： select 字段 from 表名 where username like ‘%k%’; http://www.sql.com/xxx.php?search=test 假设search为存在注入的参数 http://www.sql.com/xxx.php?search=test&#39; 语句报错 http://www.sql.com/xxx.php?search=test%&#39; and 1=1 and &#39;%&#39;=&#39; 页面正常返回结果 http://www.sql.com/xxx.php?search=test%&#39; and 1=2 and &#39;%&#39;=&#39; 页面返回错误 常见SQL注入过滤的绕过1-1.and/or的过滤/拦截双写使用运算符(||、&amp;&amp;)直接使用拼接=号使用异或注入 1-2.空格被过滤/拦截多层括号嵌套改用+号使用注释/**/and/or后面可以跟上偶数个!、~可以替代空格，也可以混合使用(规律又不同)，and/or前的空格可用省略%09, %0a, %0b, %0c, %0d, %a0等部分不可见字符可也代替空格（因为Windows的解析机制无法使用特殊字符代替空格，需要Linux的服务器环境才行） 1-3.括号被过滤/拦截order by 大小比较盲注（见下面的讲解） 1-4.逗号被过滤/拦截改用盲注 使用join语句代替，如union select 1,2,3 可改为 union select join(select 1) join(select 2) join(select 3) substr(data from 1 for 1)相当于substr(data,1,1)、limit 9 offset 4相当于limt 9,4 1-5.information_schema被过滤/拦截利用innodb存储引擎(需要Mysql版本在5.5.x后并且Mysql开启了innoDB引擎)，例如下： select table_name from mysql.innodb_table_stats where database_name=database(); select table_name from mysql.innodb_index_stats where database_name=database(); 接下来的四个只能用于查表名，无法查询列名，所以进一步获取数据还需无列名注入sys.schema_auto_increment_columnssys.x$schema_table_statistics_with_buffersys.schema_table_statistics_with_buffersys.x$ps_schema_table_statistics_io 那么接下来就补充一下无列名注入吧 利用join进行无列名注入（使用别名）join … using(xx) 当知道表名为users时，使用如下语句得到列名第一列：?id=-1’union all selectfrom (select from users as a join users b)c# 第二列：?id=-1’ union all selectfrom (select from users as a join users b using(id))c–+ 第三列：?id=-1’ union all selectfrom (select from users as a join users b using(id,username))c–+ 后面的列名可以此类推 1-6.单双引号被被过滤/拦截/转义 可根据sql语句，使用转移符号逃逸出一个单/双引号，例题可参考[BJDCTF 2nd]简单注入 需要逃逸单引号的情况：尝试是否存在编码问题而产生的SQL注入。不需要逃逸单引号的情况：字符串可用十六进制(hex函数)表示、也可通过进制转换函数表示成其他进制或者使用其他编码，如char()SELECT FROM Users WHERE username = CHAR(97, 100, 109, 105, 110) 还可以使用%2527主要绕过magic_quotes_gpc过滤，因为%25解码为%,结合后面的27也就是%27也就是’，所以成功绕过过滤。 1-7.数字和单个字母被过滤/拦截false或!pi()：0 true或!!pi()：1 true+true：2 floor(pi())：3 ceil(pi())：4 floor(version())：5 ceil(version())：6 ceil(pi()+pi())：7 floor(version()+pi())：8 floor(pi()*pi())：9 ceil(pi()*pi())：10 ceil(pi()*pi())+true：11 ceil(pi()+pi()+version())：12 floor(pi()*pi()+pi())：13 ceil(pi()*pi()+pi())：14 ceil(pi()*pi()+version())：15 floor(pi()*version())：16 ceil(pi()*version())：17 ceil(pi()*version())+true：18 floor((pi()+pi())*pi())：19 ceil((pi()+pi())*pi())：20 ceil(ceil(pi())*version())：21 ceil(pi()*ceil(pi()+pi()))：22 ceil((pi()+ceil(pi()))*pi())：23 ceil(pi())*ceil(version())：24 floor(pi()*(version()+pi()))：25 floor(version()*version())：26 ceil(version()*version())：27 ceil(pi()*pi()*pi()-pi())：28 floor(pi()*pi()*floor(pi()))：29 使用conv([0-9],10,36)可以表示0~9的数字，conv([10~35],10,36)可以表示a~z单个字母，conv([35+],10,36)可自行按照三十六进制转换 1-8.其他系统关键字被过滤/拦截双写绕过关键字过滤使用同义函数/语句代替，如if函数可用如下语句代替。 case when condition then 1 else 0 end 1-9.等号被过滤使用in或like关键字绕过 1-10.过滤sleep() BENCHMARK(count,expr)BENCHMARK()函数重复countTimes次执行表达式expr，它可以用于计时MySQL处理表达式有多快。结果值总是0。 笛卡尔积select if(1=1,(SELECT count(*) FROM information_schema.columns A, information_schema.columns B),0); GET_LOCK在一个session中可以先锁定一个变量例如：select get_lock(‘smi1e’,1)然后通过另一个session 再次执行get_lock函数 select get_lock(‘smi1e’,5),此时会产生5 秒的延迟，其效果类似于sleep(5)。但是利用场景是有条件限制的：需要提供长连接。在Apache+PHP搭建的环境中需要使用 mysql_pconnect函数来连接数据库。 RLIKE/REGEXP通过rpad或repeat构造长字符串，加以计算量大的pattern，通过repeat的参数可以控制延时长短。select rpad(‘a’,4999999,’a’) RLIKE concat(repeat(‘(a.*)+’,30),’b’)","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"学习","slug":"学习","permalink":"/tags/学习/"},{"name":"SQL注入漏洞","slug":"SQL注入漏洞","permalink":"/tags/SQL注入漏洞/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"随手写写20.12","slug":"随手写写20.12","date":"2020-12-31T07:10:02.000Z","updated":"2021-09-12T14:13:14.250Z","comments":true,"path":"2020/12/31/随手写写20.12/","link":"","permalink":"/2020/12/31/随手写写20.12/","excerpt":"","text":"发牢骚!刚刚建好不久的空网站，空空的 写点啥呢 自己的博客搭好了QWQ，主要还是当笔记本/日记本用吧，是懒狗新人的小本本（bushi） 希望在未来很多年，这个博客能跟着我走下去，见证我的进步，见证我的蜕变，我会好好对它的，等着，我迟早把网站大变样，靠自己双手，写一个自己的网页。 QWQ加油！","categories":[{"name":"生活","slug":"生活","permalink":"/categories/生活/"}],"tags":[{"name":"悦读","slug":"悦读","permalink":"/tags/悦读/"},{"name":"生活","slug":"生活","permalink":"/tags/生活/"}],"keywords":[{"name":"生活","slug":"生活","permalink":"/categories/生活/"}]}]}