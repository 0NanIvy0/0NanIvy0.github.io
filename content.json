{"meta":{"title":"NanIvy","subtitle":null,"description":"淡淡无名，月下起舞。","author":"NanIvy","url":""},"pages":[{"title":"bangumi","date":"2020-12-10T13:32:48.000Z","updated":"2021-03-02T09:06:22.259Z","comments":false,"path":"bangumi/index.html","permalink":"/bangumi/index.html","excerpt":"","text":"","keywords":null},{"title":"about","date":"2020-10-31T04:14:36.000Z","updated":"2021-07-14T05:50:53.793Z","comments":false,"path":"about/index.html","permalink":"/about/index.html","excerpt":"","text":"[ロリが好きなのNanIvy] 与&nbsp; NanIvy&nbsp; （ 菜菜子萌新 ） 对话中... bot_ui_ini()","keywords":"关于我"},{"title":"client","date":"2018-12-20T15:13:35.000Z","updated":"2020-10-31T07:26:27.764Z","comments":false,"path":"client/index.html","permalink":"/client/index.html","excerpt":"","text":"直接下载 or 扫码下载：","keywords":"Android客户端"},{"title":"comment","date":"2020-10-30T15:13:48.000Z","updated":"2021-07-12T08:02:54.847Z","comments":true,"path":"comment/index.html","permalink":"/comment/index.html","excerpt":"","text":"念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》","keywords":"留言板"},{"title":"donate","date":"2020-10-30T15:13:05.000Z","updated":"2020-11-01T12:21:18.625Z","comments":false,"path":"donate/index.html","permalink":"/donate/index.html","excerpt":"","text":"","keywords":"谢谢饲主了喵~"},{"title":"lab","date":"2012-10-31T06:47:59.000Z","updated":"2021-07-12T08:25:48.543Z","comments":false,"path":"lab/index.html","permalink":"/lab/index.html","excerpt":"","text":"NanIvyの实验室Sakura主题yyds 绝赞装修中~","keywords":"Lab实验室"},{"title":"music","date":"2020-10-31T05:14:28.000Z","updated":"2021-07-12T08:04:02.637Z","comments":false,"path":"music/index.html","permalink":"/music/index.html","excerpt":"","text":"","keywords":"喜欢的音乐"},{"title":"tags","date":"2018-12-12T14:14:16.000Z","updated":"2020-03-16T10:41:30.000Z","comments":true,"path":"tags/index.html","permalink":"/tags/index.html","excerpt":"","text":""},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2020-03-16T10:41:30.000Z","comments":true,"path":"rss/index.html","permalink":"/rss/index.html","excerpt":"","text":""},{"title":"video","date":"2018-12-20T15:14:38.000Z","updated":"2020-10-31T07:57:00.590Z","comments":false,"path":"video/index.html","permalink":"/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '放送时间: 2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 番组计划 这里将是永远的回忆 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }","keywords":"B站"},{"title":"links","date":"2020-10-31T07:11:06.000Z","updated":"2021-07-12T07:48:59.936Z","comments":true,"path":"links/index.html","permalink":"/links/index.html","excerpt":"","text":"","keywords":"友人帐"},{"title":"theme-sakura","date":"2020-10-31T06:53:25.000Z","updated":"2021-07-12T07:51:21.306Z","comments":false,"path":"theme-sakura/index.html","permalink":"/theme-sakura/index.html","excerpt":"","text":"Hexo主题Sakura修改自WordPress主题Sakura，感谢原作者Mashiro以及感谢hojun大佬的努力。","keywords":"Hexo 主题 Sakura 🌸"}],"posts":[{"title":"HTML学习笔记——HTML基础","slug":"HTML学习笔记——HTML基础","date":"2021-07-13T01:07:22.000Z","updated":"2021-07-18T09:29:37.211Z","comments":true,"path":"2021/07/13/HTML学习笔记——HTML基础/","link":"","permalink":"/2021/07/13/HTML学习笔记——HTML基础/","excerpt":"","text":"HTML基本标签head标签在HTML中，一般来说，只有6个标签能放在head标签内。 ①title标签​ 在HTML中，title标签唯一的作用就是定义网页的标题。 ②meta标签关键词，给搜索引擎。 在HTML中，meta标签有两个重要的属性：name和http-equiv。 name属性 属性值 说明 keywords 网页的关键字，可以是多个，而不仅仅是一个 description 网页的描述 author author copyright 版权信息 重点记住keywords，description。 http-equiv属性在HTML中，meta标签的http-equiv属性只有两个重要作用：定义网页所使用的编码；定义网页自动刷新跳转。 （1）定义网页所使用的编码 语法： &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;/&gt; 说明： 这段代码告诉浏览器该页面所使用的编码是utf-8。不过在HTML5标准中，上面这句代码可以简写为： &lt;meta charset=&quot;utf-8&quot; /&gt; 如果你发现页面打开是乱码，很可能就是没有加上这一句代码。在实际开发中，为了确保不出现乱码，我们必须要在每一个页面中加上。 （2）定义网页自动刷新跳转 语法： &lt;meta http-equiv=&quot;refresh&quot; content=&quot;6;url=http://www.baidu.com&quot;/&gt; 说明： 这段代码表示当前页面在6秒后会自动跳转到http://www.baidu.com这个页面。实际上，很多“小广告”网站就是用这个来实现页面定时跳转的。 ③link标签在HTML中，link标签用于引入外部样式文件（CSS文件）。这也是属于CSS部分的内容，这里不需要深究。 ④style标签在HTML中，style标签用于定义元素的CSS样式，在HTML中不需要深入研究。 ⑤script标签在HTML中，script标签用于定义页面的JavaScript代码，也可以引入外部JavaScript文件。在JavaScript部分详细学习，这里不需要深究。 ⑥base标签这个标签一点意义都没有，可以直接忽略，知道有这么一个标签就行了。 HTML文本标签标题h1~6 这里要注意一下，一个页面一般只能有一个h1标签，而h2到h6标签可以有多个。其中，h1表示的是这个页面的大标题。 &lt;body&gt; &lt;h1&gt;这是一级标题&lt;/h1&gt; &lt;h2&gt;这是二级标题&lt;/h2&gt; &lt;h3&gt;这是三级标题&lt;/h3&gt; &lt;h4&gt;这是四级标题&lt;/h4&gt; &lt;h5&gt;这是五级标题&lt;/h5&gt; &lt;h6&gt;这是六级标题&lt;/h6&gt; &lt;/body&gt; 段落标签段落标签 &lt;p&gt;&lt;/p&gt; 换行标签 &lt;br/&gt; 文本标签 （1）粗体标签：strong、b strong标签和b标签的加粗效果是一样的。不过在实际开发中，如果想要对文本实现加粗效果，尽量使用strong标签，而不要使用b标签。这是因为strong标签比b标签更具有语义性。 （2）斜体标签：i、em、cite 在实际开发中，如果想要实现文本的斜体效果，尽量使用em标签，而不是i标签或cite标签。这也是因为em标签比其他两个标签的语义性更好。 （3）上标标签：sup 如果你想要将某个数字或某些文字变成上标效果，只要把这个数字或文字放在标签内就可以了。 如：&lt;p&gt;(a+b)&lt;sup&gt;2&lt;/sup&gt;=a&lt;sup&gt;2&lt;/sup&gt;+b&lt;sup&gt;2&lt;/sup&gt;+2ab&lt;/p&gt; （4）下标标签：sub 同理。 （5）中划线标签：s 中划线效果一般用于显示那些不正确或者不相关的内容，常用于商品促销的标价中。大家在电商网站购物时肯定经常见到这种效果。 不过等学了CSS之后，对于删除线效果，一般用CSS来实现，几乎不会用s标签来实现。 &lt;p&gt;&lt;s&gt;原价:￥6.50/kg&lt;/s&gt;&lt;/p&gt; （6）下划线标签：u 等学了CSS之后，对于下划线效果，一般用CSS来实现，几乎不会用u标签来实现。 &lt;p&gt;&lt;u&gt;啊啊啊&lt;/u&gt;Web技术学习&lt;/p&gt; （7）大字号标签：big （8）小字号标签：small 重要的文本标签 标签 语义 说明 strong strong（强调） 粗体 em emphasized（强调） 斜体 sup superscripted（上标） 上标 sub subscripted（下标） 下标 水平线标签是 &lt;hr/&gt; div标签在HTML中，我们可以使用“div标签”来划分HTML结构，从而配合CSS来整体控制某一块的样式。div标签最重要的用途是划分区域，然后结合CSS针对该区域进行样式控制，这一点我们学了CSS才会知道。 块元素和行内元素标签，也叫“元素”，例如p标签又叫p元素。叫法不同，意思相同。 在HTML中，根据元素的表现形式，一般可以分为两类（暂时不考虑inline-block）。 （1）块元素（block） 在HTML中，块元素在浏览器显示状态下将占据整一行，并且排斥其他元素与其位于同一行。此外，一般情况下，块元素内部可以容纳其他块元素和行内元素。(非全部) 块元素 说明 h1~h6 标题元素 p 段落元素 div div元素 hr 水平线 ol 有序列表 ul 无序列表 （1）块元素独占一行，排斥其他元素（包括块元素和行内元素）与其位于同一行。 （2）块元素内部可以容纳其他块元素和行内元素。 （2）行内元素（inline） 在HTML中，行内元素跟块元素恰恰相反，行内元素是可以与其他行内元素位于同一行的。此外，行内元素内部（标签内部）只可以容纳其他行内元素，不可以容纳块元素。(常见) 行内元素 说明 strong 粗体元素 em 斜体元素 a 超链接 span 常用行内元素，结合CSS定义样式 （1）行内元素可以与其他行内元素位于同一行。 （2）行内元素内部可以容纳其他行内元素，但不可以容纳块元素。 特殊符号空格： &amp;nbsp ; 敲黑板 其他随便了解就行 不一定非要代码 可以直接输入。 HTML列表有序列表在HTML中，有序列表中的各个列表项是有顺序的。有序列表从 ol 开始，到 /ol 结束。有序列表的列表项是有先后顺序的，一般采用数字或字母作为顺序，默认是采用数字顺序。 &lt;ol&gt; &lt;li&gt;列表项&lt;/li&gt; &lt;li&gt;列表项&lt;/li&gt; &lt;li&gt;列表项&lt;/li&gt; &lt;/ol&gt; ol，即ordered list（有序列表）；li，即list（列表项）。 在HTML中，我们可以使用type属性来改变列表项符号。默认情况下，有序列表使用数字作为列表项符号。 属性值 列表项符号 1 阿拉伯数字：1、2、3…… a 小写英文字母：a、b、c…… A 大写英文字母：A、B、C…… i 小写罗马数字：i、ii、iii…… I 大写罗马数字：I、II、III…… 对于有序列表的列表项符号，等学了CSS之后，我们可以放弃type属性，而使用list-style-type属性。 无序列表无序列表，很好理解，有序列表的列表项是有一定顺序的，而无序列表的列表项是没有顺序的。默认情况下，无序列表的列表项符号是●，不过可以通过type属性来改变其样式。 &lt;ul&gt; &lt;li&gt;列表项&lt;/li&gt; &lt;li&gt;列表项&lt;/li&gt; &lt;li&gt;列表项&lt;/li&gt; &lt;/ul&gt; ul，即unordered list（无序列表）。li，即list（列表项）。 在无序列表中，type属性取值如下表所示。 属性值 列表项符号 disc 实心圆●（默认值） circle 空心圆○ square 正方形■ 跟有序列表一样，对于无序列表的列表项符号，等学了CSS之后，可以放弃type属性，而使用list-style-type属性。 此外，对于无序列表来说，还有以下两点要注意： （1）ul元素的子元素只能是li，不能是其他元素。 （2）ul元素内部的文本，只能在li元素内部添加，不能在li元素外部添加。 定义列表在HTML中，定义列表由两部分组成：名词和描述。 &lt;dl&gt; &lt;dt&gt;名词&lt;/dt&gt; &lt;dd&gt;描述&lt;/dd&gt; …… &lt;/dl&gt; dl即definition list（定义列表）；dt即definition term（定义名词）；而dd即definition description（定义描述）。 在实际开发中，定义列表虽然用得比较少，但是在某些高级效果（如自定义表单）中也会用到。在HTML入门阶段，了解一下就行。 HTML表格基本结构在HTML中，一个表格一般会由以下3个部分组成。 （1）表格：table标签 （2）行：tr标签 （3）单元格：td标签 tr，指的是table row（表格行）；td，指的是table data cell（表格单元格）。 由table和/table表示整个表格的开始和结束，tr和/tr表示行的开始和结束，而td和/td表示单元格的开始和结束。 在表格中，有多少组“tr /tr”，就表示有多少行。 &lt;table&gt; &lt;tr&gt; &lt;td&gt;单元格1&lt;/td&gt; &lt;td&gt;单元格2&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;单元格3&lt;/td&gt; &lt;td&gt;单元格4&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; 单元格1 单元格2 单元格3 单元格4 表格标题：caption一个表格只能有一个标题，也就是只能有一个caption标签。在默认情况下，标题都是位于整个表格内的第一行。 如： &lt;table&gt; &lt;caption&gt;表格标题&lt;/caption&gt;。。。。。。。&lt;/table&gt; 表头单元格：th在HTML中，单元格其实有两种：表头单元格，使用th标签；表行单元格，使用td标签。 th，指的是table header cell（表头单元格）。td，指的是table data cell（表行单元格）。 th和td在本质上都是单元格，但是并不代表两者可以互换，两者具有以下两种区别。 当然，对于表头单元格，可能会使用td来代替th，但是不建议这样做。学习HTML的目的就是，在需要的地方用到正确的标签（也就是语义化）。 &lt;body&gt; &lt;table&gt; &lt;caption&gt;考试成绩表&lt;/caption&gt; &lt;tr&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;语文&lt;/th&gt; &lt;th&gt;英语&lt;/th&gt; &lt;th&gt;数学&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;小明&lt;/td&gt; &lt;td&gt;80&lt;/td&gt; &lt;td&gt;80&lt;/td&gt; &lt;td&gt;80&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;小红&lt;/td&gt; &lt;td&gt;90&lt;/td&gt; &lt;td&gt;90&lt;/td&gt; &lt;td&gt;90&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;小杰&lt;/td&gt; &lt;td&gt;100&lt;/td&gt; &lt;td&gt;100&lt;/td&gt; &lt;td&gt;100&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; 表格语义化一个完整的表格包含：table、caption、tr、th、td。为了更深一地对表格进行语义化，HTML引入了thead、tbody和tfoot标签。 thead、tbody和tfoot把表格划分为3部分：表头、表身、表脚。有了这些标签，表格语义更加良好，结构更加清晰，也更具有可读性和可维护性。 &lt;table&gt; &lt;caption&gt;表格标题&lt;/caption&gt; &lt;!--表头--&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;表头单元格1&lt;/th&gt; &lt;th&gt;表头单元格2&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;!--表身--&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;表行单元格1&lt;/td&gt; &lt;td&gt;表行单元格2&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;表行单元格3&lt;/td&gt; &lt;td&gt;表行单元格4&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;!--表脚--&gt; &lt;tfoot&gt; &lt;tr&gt; &lt;td&gt;标准单元格5&lt;/td&gt; &lt;td&gt;标准单元格6&lt;/td&gt; &lt;/tr&gt; &lt;/tfoot&gt; &lt;/table&gt; 表脚（tfoot）往往用于统计数据的。对于thead、tbody和tfoot标签，不一定全部都上，例如tfoot就很少用。一般情况下，我们都是根据实际需要来使用这些标签。 thead、tbody和tfoot标签也是表格中非常重要的标签，它从语义上区分了表头、表身和表脚，很多人容易忽略它们。 此外，thead、tbody和tfoot除了使得代码更具有语义之外，还有另外一个重要作用：方便分块来控制表格的CSS样式。 合并行：rowspan在设计表格时，有时我们需要将“横向的N个单元格”或者“纵向的N个单元格”合并成一个单元格（类似word的表格合并），这个时候就需要用到“合并行”或“合并列”。这一节，我们先来介绍一下合并行。 在HTML中，我们可以使用rowspan属性来合并行。所谓的合并行，指的是将“纵向的N个单元格”合并。 语法： &lt;td rowspan = &quot;跨越的行数&quot;&gt;&lt;/td&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;姓名:&lt;/td&gt; &lt;td&gt;小明&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td rowspan=&quot;2&quot;&gt;喜欢水果:&lt;/td&gt; &lt;td&gt;苹果&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;香蕉&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; 合并列：colspan在HTML中，我们可以使用colspan属性来合并列。所谓的合并列，指的是将“横向的N个单元格”合并。 语法 &lt;td colspan = &quot;跨越的列数&quot;&gt;&lt;/td&gt; &lt;table&gt; &lt;tr&gt; &lt;td colspan=&quot;2&quot;&gt;前端开发&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;HTML&lt;/td&gt; &lt;td&gt;CSS&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;JavaScript&lt;/td&gt; &lt;td&gt;jQuery&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; ​ HTML图片图片标签任何网页都少不了图片，一个图文并茂的页面，可以使得用户体验更好。如果想让网站获得更多的流量，也需要从“图文并茂”这个角度挖掘一下。 在HTML中，我们可以使用img标签来显示一张图片。对于img标签，只需要掌握它的3个属性：src、alt和title。 语法 &lt;img src=&quot;&quot; alt=&quot;&quot; title=&quot;&quot; /&gt; src属性src用于指定这个图片所在的路径，这个路径可以是相对路径，也可以是绝对路径。 任何一个图片必须指定src属性才可以显示。也就是说，src是img标签必不可少的属性。 alt属性和title属性alt和title都是用于指定图片的提示文字。一般情况下，alt和title的值是相同的。不过两者也有很大的不同。 alt：&lt;!DOCTYPE html&gt; 实际上，当我们把“img/xxx.png”去掉（也就是图片无法显示）后，此时可以看到浏览器会显示alt的提示文字，如下图所示。如果没有加上alt属性值，图片不显示时，就不会有提示文字。 title：当我们把鼠标移到图片上时，就会显示title中的提示文字，如下所示。 &lt;!DOCTYPE html&gt; 在实际开发中，对于img标签，src和alt这两个是必选属性，一定要添加；而title是可选属性，可加可不加。 alt属性的内容是提供给搜索引擎看的，title属性的内容是提供给用户看的 图片路径相对路径： 绝对路径： 在实际开发中，站内文件不管是图片还是超链接等,都是使用相对路径，几乎不会使用绝对路径。 这是因为如果采用绝对路径，网站文件一旦移动，则所有的路径都可能会失效。因此，只需要掌握相对路径，而绝对路径了解一下就行。 图片格式在网页中，图片格式有两种：一种是“位图”；另外一种是“矢量图”。 位图位图，又叫做“像素图”，它是由像素点组成的图片。对于位图来说，放大图片后，图片会失真；缩小图片后，图片同样也会失真。 在实际开发中，最常见位图的图片格式有3种（可以从图片后缀名看出来）：jpg（或jpeg）、png、gif。深入理解3种图片适合在哪种情况下使用，在前端开发中是非常重要的。 （1）jpg可以很好地处理大面积色调的图片，适合存储颜色丰富的复杂图片，如照片、高清图片等。此外，jpg体积较大，并且不支持透明。 （2）png是一种无损格式，可以无损压缩以保证页面打开速度。此外，png体积较小，并且支持透明，不过不适合存储颜色丰富的图片。 （3）gif图片效果最差，不过它适合制作动画。实际上，小伙伴们经常在QQ或微信上发的动图都是gif格式的。 这里来总结一下：如果想要展示色彩丰富而高品质图片，可以使用jpg格式；如果是一般图片，为了减少体积或者想要透明效果，可以使用png格式；如果是动画图片，可以使用gif格式。 矢量图矢量图，又叫做“向量图”，它是用计算机图形学中点、直线或多边形等表示出来的几何图像。 矢量图是以一种数学描述的方式来记录内容的图片格式。举个例子，可以使用y=kx来绘制一条直线，当k取不同值时就会绘制不同角度的直线，这就是矢量图的构图原理。 矢量图最大的优点是：图片无论放大、缩小或旋转等都不会失真。最大的缺点是：难以表现色彩丰富的图片效果（非常差）。 矢量图常见格式有：“.ai”、“.cdf”、“.fh”、“.swf”。其中“.swf”格式比较常见，它指的是Flash动画，其他几种格式的矢量图比较少见，可以忽略。对于矢量图，我们可以使用illustrator或者CorelDRAW这两款软件来处理。 在网页中，很少用到矢量图，除非是一些字体图标（iconfont）。不过作为初学者，只需简单了解一下即可。 对于位图和矢量图的区别，我们总结有以下4点。 （1）位图适用于展示色彩丰富的图片，而矢量图不适用于展示色彩丰富的图片。 （2）位图组成单位是“像素”，而矢量图组成单位是“数学向量”。 （3）位图受分辨率影响，当图片放大时会失真；而矢量图不受分辨率影响，当图片放大时不会失真。 （4）网页中的图片绝大多数都是位图，而不是矢量图。 HTML超链接a标签语法： &lt;a href=&quot;链接地址&quot;&gt;文本或图片&lt;/a&gt; href表示你想要跳转到那个页面的路径（也就是地址），可以是相对路径，也可以是绝对路径。 超链接的范围非常广，可以将文本设置为超链接，这个叫做“文本超链接”。也可以将图片设置为超链接，这个叫做“图片超链接”。 target属性 默认情况下，超链接都是在当前浏览器窗口打开新页面的。在HTML中，我们可以使用target属性来定义超链接打开窗口的方式。 语法： &lt;a href=&quot;链接地址&quot; target=&quot;打开方式&quot;&gt;&lt;/a&gt; a标签的target属性取值有4种，如下表所示。 属性值 说明 _self 默认值，在原来窗口打开链接 _blank 在新窗口打开链接 _parent 在父窗口打开链接 _top 在顶层窗口打开超链接 一般情况下，只会用到_blank这一个值，也只要记住这一个就够了，其他三个值不需要去深究。默认的self，可加可不加。 锚点链接有些页面内容比较多，导致页面过长，此时用户需要不停拖动浏览器上的滚动条才可以看到下面的内容。为了方便用户操作，可以使用锚点链接来优化用户体验。 在HTML中，锚点链接其实是内部链接的一种，它链接地址（也就是href）指向的是当前页面的某个部分。所谓的锚点链接，简单来说，就是点击某一个超链接，然后它就会跳到当前页面的某一部分。 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; &lt;a href=&quot;#article&quot;&gt;推荐文章&lt;/a&gt;&lt;br /&gt; &lt;a href=&quot;#music&quot;&gt;推荐音乐&lt;/a&gt;&lt;br /&gt; &lt;a href=&quot;#movie&quot;&gt;推荐电影&lt;/a&gt;&lt;br /&gt; &lt;/div&gt; ……&lt;br /&gt; ……&lt;br /&gt; ……&lt;br /&gt; ……&lt;br /&gt; ……&lt;br /&gt; ……&lt;br /&gt; ……&lt;br /&gt; ……&lt;br /&gt; &lt;div id=&quot;article&quot;&gt; &lt;h3&gt;推荐文章&lt;/h3&gt; &lt;ul&gt; &lt;li&gt;朱自清-荷塘月色&lt;/li&gt; &lt;li&gt;余光中-乡愁&lt;/li&gt; &lt;li&gt;鲁迅-阿Q正传&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; ……&lt;br /&gt; ……&lt;br /&gt; ……&lt;br /&gt; ……&lt;br /&gt; ……&lt;br /&gt; ……&lt;br /&gt; ……&lt;br /&gt; ……&lt;br /&gt; &lt;div id=&quot;music&quot;&gt; &lt;h3&gt;推荐音乐&lt;/h3&gt; &lt;ul&gt; &lt;li&gt;林俊杰-被风吹过的夏天&lt;/li&gt; &lt;li&gt;曲婉婷-在我的歌声里&lt;/li&gt; &lt;li&gt;许嵩-灰色头像&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; ……&lt;br /&gt; ……&lt;br /&gt; ……&lt;br /&gt; ……&lt;br /&gt; ……&lt;br /&gt; ……&lt;br /&gt; ……&lt;br /&gt; ……&lt;br /&gt; &lt;div id=&quot;movie&quot;&gt; &lt;h3&gt;推荐电影&lt;/h3&gt; &lt;ul&gt; &lt;li&gt;蜘蛛侠系列&lt;/li&gt; &lt;li&gt;钢铁侠系统&lt;/li&gt; &lt;li&gt;复仇者联盟&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 当点击“推荐文章”“推荐音乐”“推荐电影”这3个超链接后，页面就会自动滚动到相应的部分。仔细观察这个例子就可以知道，想要实现锚点链接，需要定义以下2个参数。 其中，id属性就是元素的名称，这个id名是随便起的（一般是英文）。不过在同一个页面中，id是唯一的，也就是说一个页面不允许出现相同的id。 最后要注意一点，a标签的href属性取值时，需要在id前面加上“#”（井号），以表示这是一个锚点链接。 HTML表单表单介绍表单标签：（5种） form、input、textarea、select和option 从外观上来划分，表单可以分为以下8种。 （1）单行文本框 （2）密码文本框 （3）单选框 （4）复选框 （5）按钮 （6）文件上传 （7）多行文本框 （8）下拉列表 form标签在HTML中，我们都知道表格的行（tr）、单元格（th、td）等都必须放在table标签内部。创建一个表单，跟创建一个表格一样，也必须要把所有表单标签放在form标签内部。 表单跟表格，这是两个完全不一样的概念。记住，常说的表单，指的是文本框、按钮、单选框、复选框、下拉列表等的统称。 语法： &lt;form&gt; //各种表单标签 &lt;/form&gt; 例： &lt;body&gt; &lt;form&gt; &lt;input type=&quot;text&quot; value=&quot;这是一个单行文本框&quot;/&gt;&lt;br/&gt; &lt;textarea&gt;这是一个多行文本框&lt;/textarea&gt;&lt;br/&gt; &lt;select&gt; &lt;option&gt;HTML&lt;/option&gt; &lt;option&gt;CSS&lt;/option&gt; &lt;option&gt;JavaScript&lt;/option&gt; &lt;/select&gt; &lt;/form&gt; &lt;/body&gt; form标签属性 属性 说明 name 表单名称 method 提交方式 action 提交地址 target 打开方式 enctype 编码方式 name属性： 在一个页面中，表单可能不止一个，每一个form标签就是一个表单。为了区分这些表单，可以使用name属性来给表单进行命名。 例： &lt;form name=&quot;myForm&quot;&gt;&lt;/form&gt; method属性： 在form标签中，method属性用于指定表单数据使用哪一种http提交方法。method属性取值有两个：一个是“get”，另外一个是“post”。 get的安全性较差，而post的安全性较好。所以在实际开发中，使用post比较多。 举例： &lt;form method=&quot;post&quot;&gt;&lt;/form&gt; action属性： 在form标签中，action属性用于指定表单数据提交到哪一个地址进行处理。 举例： &lt;form action=&quot;index.php&quot;&gt;&lt;/form&gt; target属性： form标签的target属性跟a标签的target属性是一样的，都是用来指定窗口的打开方式。一般情况下，只会用到“_blank”这一个属性值。 举例： &lt;form target=&quot;_blank&quot;&gt;&lt;/form&gt; enctype属性： 在form标签中，enctype属性用于指定表单数据提交的编码方式。一般情况下，不需要设置，除非用到上传文件功能。 input标签在HTML中，大多数表单都是使用input标签来实现的。 语法： &lt;input type=&quot;表单类型&quot; /&gt; input是自闭合标签，它是没有结束符号的。其中type属性取值： text-单行文本框 password-密码文本框 radio-单选框 checkbox-多选框 button/submit/reset-按钮file-文件上传 不同属性对应不同的效果。 input-text：单行文本框语法： &lt;input type=&quot;text&quot; /&gt; &lt;form method=&quot;post&quot;&gt; 姓名：&lt;input type=&quot;text&quot; /&gt; &lt;/form&gt; 单行文本框属性： 属性 说明 value 设置文本框的默认值，也就是默认情况下文本框 size 设置文本框的长度 maxlength 设置文本框中最多可以输入的字符数 value属性用于设置单行文本框中默认的文本，如果没有设置，就是空白。 size属性可以用来设置单行文本框的长度，不过在实际开发中，我们一般不会用到这个属性，而是使用CSS来控制。 外观上看不出maxlength加上与不加上有什么区别，不过当输入内容后，发现设置maxlength=”5”的单行文本框最多只能输入5个字符、 input-password密码文本框：密码文本框在外观上与单行文本框相似，两者拥有相同的属性（value、size、maxlength等）。不过它们是有着本质上的区别的：在单行文本框中输入的字符是可见的，而在密码文本框中输入的字符不可见。 语法： &lt;input type=&quot;password&quot; /&gt; &lt;form method=&quot;post&quot;&gt; 账号：&lt;input type=&quot;text&quot; /&gt;&lt;br /&gt; 密码：&lt;input type=&quot;password&quot; /&gt; &lt;/form&gt; 属性同上text单行文本框。 input-radio单选框：在HTML中，单选框也是使用input标签来实现的，其中type属性取值为“radio”。 语法： &lt;input type=&quot;radio&quot; name=&quot;组名&quot; value=&quot;取值&quot; /&gt; &lt;form method=&quot;post&quot;&gt; 性别: &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;男&quot; /&gt;男 &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;女&quot; /&gt;女 &lt;/form&gt; name属性表示单选按钮所在的组名，而value表示单选按钮的取值，这两个属性必须要设置。 checked属性： 在默认情况下，让第一个单选框选中，可以使用checked属性来实现。 可能看到checked属性没有属性值，这是HTML5的最新写法。下面两句代码其实是等价的，不过一般都是采用缩写形式。 &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;男&quot; checked /&gt;男 &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;女&quot; /&gt;女 &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;男&quot; checked /&gt;男 &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;男&quot; checked=&quot;checked&quot; /&gt;男 重点：name属性容易遗忘，若不添加name属性，或者同一组单选框选项的name不同，则可导致一组内的单选框都可被选中，所以name属性很重要。只有同一name下的一组数据才能使单选框选项互斥。 input-checkbox复选框：在HTML中，复选框也是使用input标签来实现的，其中type属性取值为“checkbox”。单选框只能选择一项，而复选框可以选择多项。 语法： &lt;input type=&quot;checkbox&quot; name=&quot;组名&quot; value=&quot;取值&quot; /&gt; &lt;form method=&quot;post&quot;&gt; 你喜欢的水果：&lt;br/&gt; &lt;input type=&quot;checkbox&quot; name=&quot;fruit&quot; value=&quot;苹果&quot;/&gt;苹果 &lt;input type=&quot;checkbox&quot; name=&quot;fruit&quot; value=&quot;香蕉&quot;/&gt;香蕉 &lt;input type=&quot;checkbox&quot; name=&quot;fruit&quot; value=&quot;西瓜&quot;/&gt;西瓜 &lt;input type=&quot;checkbox&quot; name=&quot;fruit&quot; value=&quot;李子&quot;/&gt;李子 &lt;/form&gt; name和value属性同上单选框，务必要设置。 input-button普通按钮在HTML中，普通按钮一般情况下都是配合JavaScript来进行各种操作的。 语法： &lt;input type=&quot;button&quot; value=&quot;取值&quot; /&gt; &lt;form method=&quot;post&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;起飞&quot;/&gt; &lt;/form&gt; value的取值就是按钮上的文字。 input-submit提交按钮在HTML中，提交按钮一般都是用来给服务器提交数据的。我们可以把提交按钮看成是一种特殊功能的普通按钮。 语法： &lt;input type=&quot;submit&quot; value=&quot;取值&quot;/&gt; 提交按钮只能提交它“所在form标签”内表单中的内容 input-reset重置按钮在HTML中，重置按钮一般用来清除用户在表单中输入的内容。重置按钮也可以看成是具有特殊功能的普通按钮。 语法： &lt;input type=&quot;reset&quot; value=&quot;取值&quot; /&gt; 重置按钮只能清空它“所在form标签”内表单中的内容，对于当前所在form标签之外的表单清除是无效的。 button标签普通按钮、提交按钮以及重置按钮这3种按钮都是使用input标签来实现的。其实还有一种按钮是使用button标签来实现的。 语法： &lt;button&gt;&lt;/button&gt; 在实际开发中，比较少用到button标签。 input-file文件上传文件上传功能的实现需要用到后端技术，文件上传功能经常用到。 在HTML中，文件上传也是使用input标签来实现的，其中type属性取值为file。 语法： &lt;input type=&quot;file&quot; /&gt; textarea标签：多行文本框单行文本框只能输入一行文本，而多行文本框却可以输入多行文本。在HTML中，多行文本框使用的是textarea标签，而不是input标签。 语法： &lt;textarea rows=&quot;行数&quot; cols=&quot;列数&quot; value=&quot;取值&quot;&gt;默认内容&lt;/textarea&gt; 多行文本框的默认显示文本是在标签对内部设置，而不是在value属性中设置的。一般情况下，不需要设置默认显示文本。 文本框总结对于文本框，现在我们可以总结出以下2点。 （1）HTML有3种文本框：单行文本框、密码文本框、多行文本框。 （2）单行文本框和密码文本框使用的都是input标签，多行文本框使用的是textarea标签。 select标签：下拉列表在HTML中，下拉列表由select和option这两个标签配合使用来表示的。这一点跟无序列表很像，其中无序列表是由ul和li这两个标签配合使用来表示。为了更好地理解，可以把下拉列表看成是一种“特殊的无序列表”。 语法： &lt;select&gt; &lt;option&gt;选项内容&lt;/option&gt; …… &lt;option&gt;选项内容&lt;/option&gt; &lt;/select&gt; select标签属性 属性 说明 multiple 设置下拉列表可以选择多项 size 设置下拉列表显示几个列表项，取值为整数 multiple属性： 下拉列表的multiple属性没有属性值，这是HTML5的最新写法。 默认情况下，下拉列表只能选择一项，我们可以通过multiple属性设置下拉列表可以选择多项。想要选取多项，可以使用“Ctrl+鼠标左键”来选取。 &lt;select multiple&gt; &lt;option&gt;HTML&lt;/option&gt; &lt;option&gt;CSS&lt;/option&gt; &lt;option&gt;jQuery&lt;/option&gt; &lt;option&gt;JavaScript&lt;/option&gt; &lt;option&gt;Vue.js&lt;/option&gt; &lt;option&gt;HTML5&lt;/option&gt; &lt;option&gt;CSS3&lt;/option&gt; &lt;/select&gt; size属性： 设置下拉列表显示几个列表项，取值为整数。 有些小伙伴将size取值为1、2、3时，会发现Chrome浏览器无效。这是因为Chrome浏览器最低是4个选项，我们只能选取4及以上数字。 &lt;select size=&quot;5&quot;&gt; &lt;option&gt;HTML&lt;/option&gt; &lt;option&gt;CSS&lt;/option&gt; &lt;/select&gt; option标签属性 属性 说明 selected 是否选中 value 选项值 selected属性： &lt;select size=&quot;5&quot;&gt; &lt;option&gt;HTML&lt;/option&gt; &lt;option&gt;CSS&lt;/option&gt; &lt;option selected&gt;jQuery&lt;/option&gt; &lt;/select&gt; selected属性表示列表项是否被选中，它是没有属性值的，这也是HTML5的最新写法，这个跟单选框中的checked属性也是一样的。 value属性： 对于value属性，不多说，几乎所有表单元素都有value属性，这个属性是配合JavaScript以及服务器进行操作的。 语法： &lt;select size=&quot;5&quot;&gt; &lt;option value=&quot;HTML&quot;&gt;HTML&lt;/option&gt; &lt;option value=&quot;CSS&quot;&gt;CSS&lt;/option&gt; &lt;/select&gt; 敲黑板：标签label语义化规范：为了更好地语义化，表单元素与后面的文本一般都需要借助label标签关联起来。 同时还能增加用户体验。 如：（除了选项同时也适用于文本框） &lt;label&gt;&lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;男&quot; /&gt;男&lt;/label&gt; &lt;label&gt;&lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;女&quot; /&gt;女&lt;/label&gt; 表单注意事项：1、表单元素那么多，而且每一种自己还有好几个属性，应该怎么记忆呢？ 对于初学者来说，表单记忆是最关心也是最为头疼的一件事。在HTML入门时，我们不需要花太多时间去记忆这些标签或属性，只需要感性认知即可。忘了的时候，就回来翻一下。此外，编辑器一般也会有代码提示，写多了自然就会记住了。 2、表单元素是否一定要放在form标签内呢？ 表单元素不一定都要放在form标签内。对于要与服务器进行交互的表单元素就必须放在form标签内才有效。如果表单元素不需要跟服务器进行交互，那就没必要放在form标签内。 HTML框架iframe标签在HTML中，我们可以使用iframe标签来实现一个内嵌框架。内嵌框架，说白了，就是在当前页面再嵌入另外一个网页。 语法： &lt;iframe src=&quot;链接地址&quot; width=&quot;数值&quot; height=&quot;数值&quot;&gt;&lt;/iframe&gt; src是必选的，用于定义链接页面的地址。width和height这两个属性是可选的，分别用于定义框架的宽度和高度。 iframe实际上就是在当前页面嵌入了另外一个页面，我们也可以同时嵌入多个页面。 &lt;body&gt; &lt;iframe src=&quot;http://nanivy.space&quot; width=&quot;200&quot; height=&quot;150&quot;&gt;&lt;/iframe&gt; &lt;/body&gt; 还有什么frameset、frame标签，事实上这几个标签在HTML5标准中已经被废弃了。对于框架，我们只需要掌握iframe这一个标签就可以了。","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"学习","slug":"学习","permalink":"/tags/学习/"},{"name":"HTML","slug":"HTML","permalink":"/tags/HTML/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"近期自我总结","slug":"近期自我总结","date":"2021-07-01T07:10:02.000Z","updated":"2021-07-16T02:00:41.564Z","comments":true,"path":"2021/07/01/近期自我总结/","link":"","permalink":"/2021/07/01/近期自我总结/","excerpt":"","text":"近期总结​ 最近自己也摸鱼完一段时间了，总结自己走过来的学安全的日子，过的浑浑噩噩，难以形容。可惜浪费的时间。 ​ 但是，自己也确实该真正去尝试去做点事情了。大学时光成功鬼混一年了，什么都没学会，安全连皮毛都没学进去。静下心想想，自己果然更喜欢创造一些东西 ，或者说一种动手能力。从小我就喜欢拆家里的电器，钟表等等各种能用电的东西，说不定我还蛮适合去搞硬件？（做梦） ​ 去了解了一些东西——发现了web前端。其实给我第一印象并不好，不就是记标签，然后用标签还原网页吗？再仔细了解，其实这东西还挺有趣的？绝对不是想象中的那么简单。或许我愿意去试试。 新一年的目标​ 所以，接下来的一年，我打算好好学习web前端。 ​ 给自己定下一个小目标——学好web前端，自己写一个不错的小（静态）网站，做自己喜欢的东西，说不定我也要去兽耳科技，为爱，付出。有了追求，有了理想，接下来的我，便是努力了吧。未来还长，我愿意为之付出，加油吧，我这样的废物。 ​ 纸片人老婆们，请期待我吧，我会努力的。 ​ 淡淡无名，月下起舞。","categories":[{"name":"生活","slug":"生活","permalink":"/categories/生活/"}],"tags":[{"name":"随想","slug":"随想","permalink":"/tags/随想/"}],"keywords":[{"name":"生活","slug":"生活","permalink":"/categories/生活/"}]},{"title":"web学习笔记——CSRF","slug":"web学习笔记——CSRF","date":"2021-02-25T06:22:33.000Z","updated":"2021-07-12T07:40:16.636Z","comments":true,"path":"2021/02/25/web学习笔记——CSRF/","link":"","permalink":"/2021/02/25/web学习笔记——CSRF/","excerpt":"","text":"CSRF介绍、概念CSRF跨站点请求伪造(Cross—Site Request Forgery)，也被称为 one-click attack 或者 session riding，通常缩写为 CSRF 或者 XSRF， 是一种挟制用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法。跟跨网站脚本（XSS）相比，XSS利用的是用户对指定网站的信任，CSRF 利用的是网站对用户网页浏览器的信任。 简单理解： 攻击者盗用了你的身份，以你的名义发送恶意请求，对服务器来说这个请求是完全合法的，但是却完成了攻击者所期望的一个操作，比如以你的名义发送邮件、发消息，盗取你的账号，添加系统管理员，甚至于购买商品、虚拟货币转账等。 如下：其中Web A为存在CSRF漏洞的网站，Web B为攻击者构建的恶意网站，User C为Web A网站的合法用户。 攻击原理： 用户C打开浏览器，访问受信任网站A，输入用户名和密码请求登录网站A； ​ 2.在用户信息通过验证后，网站A产生Cookie信息并返回给浏览器，此时用户登录网站A成功，可以正常发送请求到网站A； ​ 3. 用户未退出网站A之前，在同一浏览器中，打开一个TAB页访问网站B； ​ 4. 网站B接收到用户请求后，返回一些攻击性代码，并发出一个请求要求访问第三方站点A； 5. 浏览器在接收到这些攻击性代码后，根据网站B的请求，在用户不知情的情况下携带Cookie信息，向网站A发出请求。网站A并不知道该请求其实是由B发起的，所以会根据用户C的Cookie信息以C的权限处理该请求，导致来自网站B的恶意代码被执行。 受害者只需要做下面两件事情，攻击者就能够完成CSRF攻击： 登录受信任站点 A，并在本地生成cookie； 在不登出站点A（清除站点A的cookie）的情况下，访问恶意站点B。 CSRF攻击举例GET型假设某银行网站A以GET请求来发起转账操作，转账的地址为www.xxx.com/transfer.do?accountNum=l000l&amp;money=10000，参数accountNum表示转账的账户，参数money表示转账金额。 而某大型论坛B上，一个恶意用户上传了一张图片，而图片的地址栏中填的并不是图片的地址，而是前而所说的砖账地址：&lt;img src=&quot;http://www.xxx.com/transfer.do?accountNum=l000l&amp;money=10000&quot;&gt; 当你登录网站A后，没有及时登出，这时你访问了论坛B，不幸的事情发生了，你会发现你的账号里面少了10000块… 为什么会这样呢，在你登录银行A时，你的浏览器端会生成银行A的cookie，而当你访问论坛B的时候，页面上的标签需要浏览器发起一个新的HTTP请求，以获得图片资源，当浏览器发起请求时，请求的却是银行A的转账地址www.xxx.com/transfer.do?accountNum=l000l&amp;money=10000，并且会带上银行A的cookie信息，结果银行的服务器收到这个请求后，会以为是你发起的一次转账操作，因此你的账号里边便少了10000块。 当然，绝大多数网站都不会使用GET请求来进行数据更新，因此，攻击者也需要改变思路，与时俱进。 POST型假设银行将其转账方式改成POST提交，而论坛B恰好又存在一个XSS漏洞，恶意用户在它的页面上植入如下代码： &lt;form id=&quot;aaa&quot; action=&quot;http://www.xxx.com/transfer.do&quot; metdod=&quot;POST&quot; display=&quot;none&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;accountNum&quot; value=&quot;10001&quot;/&gt; &lt;input ty。pe=&quot;text&quot; name=&quot;money&quot; value=&quot;10000&quot;/&gt; &lt;/form&gt; &lt;script&gt; var form = document.forms(&#39;aaa&#39;); form.submit(); &lt;/script&gt; 如果你此时恰好登录了银行A，且没有登出，当你打开上述页面后，脚本会将表单aaa提交，把accountNum和money参数传递给银行的转账地址http://www.xxx.com/transfer.do，同样的，银行以为是你发起的一次转账会从你的账户中扣除10000块。 CSRF防御1、尽量使用POST，限制GET GET接口太容易被拿来做CSRF攻击，看上面示例就知道，只要构造一个img标签，而img标签又是不能过滤的数据。接口最好限制为POST使用，GET则无效，降低攻击风险。 当然POST并不是万无一失，攻击者只要构造一个form就可以，但需要在第三方页面做，这样就增加暴露的可能性。 2、增加token类似一种不需要输入的“验证码”。 CSRF攻击之所以能够成功，是因为攻击者可以伪造用户的请求，该请求中所有的用户验证信息都存在于cookie中，因此攻击者可以在不知道用户验证信息的情况下直接利用用户的cookie来通过安全验证。由此可知，抵御CSRF攻击的关键在于：在请求中放入攻击者所不能伪造的信息，并且该信息总不存在于cookie之中。鉴于此，系统开发人员可以在HTTP请求中以参数的形式加入一个随机产生的token，并在服务端进行token校验，如果请求中没有token或者token内容不正确，则认为是CSRF攻击而拒绝该请求。也可以在HTML表单中加入隐藏的token，在提交表单时验证（适用范围小） 但如果网站同时存在xss、csrf，这种token防御机制可能就失效了，因为攻击者能从javascript获取token值。 3、二次确认在用户进行一些关键操作时候，产生对话框二次提示确认。 或要求输入验证码，敏感操作要进行验证码验证。 这样用户突然收到提示也会警觉起来。 参考： https://blog.csdn.net/stpeace/article/details/53512283 https://www.jianshu.com/p/67408d73c66d https://www.cnblogs.com/hyddd/archive/2009/04/09/1432744.html","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"学习","slug":"学习","permalink":"/tags/学习/"},{"name":"CSRF漏洞","slug":"CSRF漏洞","permalink":"/tags/CSRF漏洞/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"web学习笔记——http请求响应","slug":"web学习笔记——http请求响应","date":"2021-02-09T15:21:19.000Z","updated":"2021-07-16T01:12:47.678Z","comments":true,"path":"2021/02/09/web学习笔记——http请求响应/","link":"","permalink":"/2021/02/09/web学习笔记——http请求响应/","excerpt":"","text":"总结不出什么东西，直接转载大佬的 请求头User-Agent:例：User-Agent:Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.186 Safari/537.36表示客户端的软件环境。如上可以看出使用的是Window10 64位操作系统，Chrome浏览器等信息。服务器可以根据该字段评估客户端的环境从而给出不同的响应。（比如根据请求是从手机端或是电脑端发起的，返回不同版本的页面） Host：例：Host:localhost:8080表示请求者的主机地址（IP地址）和端口号。服务器端可以根据该字段进行ip过滤等操作。 Accept：例：Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,/;q=0.8表示客户端支持的数据格式，或者说客户端“希望”接受到的内容类型。这里只是希望，但是服务器具体返回什么样的内容类型，还是由服务器自己决定，但是无论服务器返回什么样的内容类型，客户端都会接收响应报文，不可能说因为内容类型不同，接收不到服务器响应报文，这不符合http协议规范。 我们通过浏览器发起get或post请求，该字段都是浏览器自动添加的，同样在服务器端也不会解析该字段的值；通过ajax请求或其他手段，我们可以设置该字段的值，但是通常也不进行设置。 该字段的应用场景可以是这样的，有两个终端，比如一个是纯文本阅读器，如Kinder（不能显示图片），另一个是移动终端（可以播放图片和视频），均向服务器请求有关“斑马”的信息，那么这时候服务器端就需要判断什么样的终端应该返回什么样的信息，那么它就可以根据Accept的信息来进行判断，如果解析到的Accept的值为“text/plain”，那么就表示客户端只支持文本类型；如果向上面例子中的那样，则表示客户端文本图片视频都可以。如果我们不加判断，当返回给文本阅读器一张图片时，可能它显示的就是乱码。 Accept-Encoding:例：Accept-Encoding:gzip, deflate, br表示客户端所支持的解码（解压缩）格式。 网路数据的传输都是占据带宽的，而将文件数据压缩能够降低数据量，减少传输时间。所以服务器在返回数据给客户端时，常常对数据进行压缩（对用户透明，通常由服务器或代理来做），而压缩的方式有多种，到底采用哪一种则需要看客户端支持哪种解码方式，这时候就可以根据header中Accept-Encoding的值。 文件或数据的压缩，由服务器或代理来做，一般不需要程序员干预；客户端接收到数据时解压缩，通常由浏览器自动完成，对用户透明。对于我们主动发起的ajax请求，一般数据量较少，不需要设置该字段。 Accept-Language:例Accept-Language:zh-CN,zh;q=0.9表示客户端支持的语言格式（不是编码格式），如中文/英文，通常浏览器直接发起请求时，浏览器会根据被设置的语言环境（默认语言），来附加上该字段。 一般我们服务器解析报文时，是不理会该字段的。他的使用场景可以是这样的，假如有个文件，有各种语言的版本，这样当不同请求发来时，我们可以根据Accept-Language的值来判断到底返回哪种语言版本给客户端。（其实这种应用场景也一般不采用判断Accept-Language字段的方法，不靠谱，还不如直接在url中体现语言版本呢） Accept-Charset：例：Accept-Charset:gbk,utf-8;q=0.8表示客户端支持编码格式。服务器在返回报文时，需要将字符按照一定的编码格式转换为字节序列发送给客户端，那么该采用哪种编码格式呢？当然作为服务器端，他可以采用任何一种编码方式，客户端都得完完整整的接收响应报文。因为目前客户端几乎都支持常见编码类型，所以服务器在返回数据时，只需要按照既定的编码方式编码，然后在响应报文中告知客户端所使用的编码方式。这样客户端在接收到报文后按照该方式进行解码，就就不会出现乱码问题。 但是，如果客户端已经定了就使用某种解码方式，那么这时候服务器端就不能那么任性了，他就需要解析Accept-Charset字段，根据这个值，来设定采用的编码方式。如上例中，以逗号分隔，客户端支持两种编码方式，gbk和utf-8（gbk优先级高于utf8），其中utf-8后的q值，表示utf-8占的“权重”。 Referer：例：Referer:http://localhost:8080/test/11.html表示当前请求是从哪个资源发起的；或者是请求的上一步的地址。 Cookie： cookie是非常重要的请求头，他是一段文本，常用来表示请求者身份等。 XFF（X-Forward-For）：它代表请求端的ip，可以有多个，中间以逗号隔开。 If-Modified-Since：例：If-Modified-Since:Thu, 29 Mar 2018 08:37:45 GMT表示客户端缓存文件的时间。字面翻译的意思是，“如果从…时间改变了”（就请再发送给我一遍新的文件）。 当客户端访问服务器的静态文件时，通常会将资源结果缓存下来，并标记一下文件的缓存时间（根据响应头中的Last-Modified字段）；当接下来再发送同样的请求时，会在请求头中添加上这个字段If-Modified-Since； 服务器端读取字段值，判断服务器端文件的最后修改时间，如果如果不晚于该值，说明浏览器缓存的文件是最新的，然后就不会重新发送文件内容，而是将相应报文的状态设置为304，表示你读取缓存的文件就可以了，这就很大程度上节省了带宽。 If-None-Match:例：If-None-Match:W/”607-1522312665174”该字段同If-Modified-Since字段一样，都是用来表示资源文件是否是最新的。只不过If-Modified-Since的值为文件的最后修改时间，而该值为资源实体的哈希值，同样是由服务器生成的。从上面的截图中我们可以看到：第一次请求时，服务器的响应报文中有字段Etag，这就是实体的哈希值，浏览器会缓存文件并记录该值。第二次请求时，请求头字段中就有If-None-Match，值为Etag的值，而服务器会判断该值与服务器中文件的哈希值是否相同，如果相同，就返回304，让浏览器读取缓存；否则会返回新的资源文件，并在响应头中设置新的Etag值。 Last-Modified/If-Modified-Since 和 Etag/If-None-Match这两对头字段都是来标记缓存资源的，但是后者的优先级要高于前者。 Cache-Control:（了解为主）例： Cache-Control:no-cache字段的字面意思为“缓存-控制”，前面我们将了几个字段表面客户端/服务器如何使用缓存机制，而这个字段就是用来控制缓存的。 Cache-Control在请求/响应报文头中均可设置，分别表明不同的意思，下面我们以响应报文为例：cache-control在响应报文的的取值可以为：public、private、no-cache、no- store、no-transform、must-revalidate、proxy-revalidate、max-age。 其中，no-cache、no-store、max-age为常用的取值。比如，服务器在响应报文中添加Cache-Control：no-store，表示浏览器或各级代理，不要缓存本次的相应内容（即使响应报文中有Etag和Last-Modified）; 比如，响应报文中有Cache-Control：no-cache，表示浏览器可以缓存响应文件，但是在使用缓存之前，必须通过令牌（Etag）来与服务器进行沟通确认缓存有效。 比如，响应报文中有Cache-Control：max-age=500，表示在接下来的500秒内，浏览器可以自主使用缓存内容，不需要向服务器发送同样的请求。 在请求报文中，也可以添加cache-control字段，其取值可以为no-cache、no-store、max-age、 max-stale、min-fresh、only-if-cached。客户端在发送请求到服务器时，可能会经过很多层代理，而这些代理可能就缓存了本次请求想要的文件，而请求中的cache-control就可以控制，是否使用代理中的缓存文件。 比如，请求报文头中有cache-control：no-cache，那就表示，代理如果返回给我缓存文件时，需要到服务器端进行确认，缓存是不是最新的。 比如，请求报文头中有cache-control：no-store，那就表示，我不需要代理中的缓存文件，我需要直接请求服务器。 所以我们可以看到，cache-control就是用来控制缓存使用的，如是否缓存，是否使用缓存，缓存到期时间等，而Last-Modified/If-Modified-Since 和 Etag/If-None-Match是标识C/S之间怎么使用缓存。缓存的使用都是服务器和客户端的默认行为，对用户和程序员的透明的，当然我们可以通过配置文件或程序修改他们的行为规则。附：http协议中对缓存的说明 响应头Etag、Last-Modified（资源最后修改时间）、cache-control在前文中已经说明。 Content-Length:例：Content-Length:607表示接收到的响应报文的总长度为607。根据这个长度，客户端可以更准确的接收和解析报文内容。或者可以根据当前接收/解析的长度占总长度的百分比，做出进度条的效果。 Accept-Ranges:例：Accept-Ranges:bytes表示服务器支持http中的Range功能，能够分段请求客户端能够分段请求服务器。我们上网时常用的“断点续传”，或者服务器所谓的“多线程下载”就是靠的服务器端的Range技术。 Range功能的请求-响应流程如此：客户端发起带range的请求： GET /test.rar HTTP/1.1 Connection: close Host: 116.1.219.219 Range: bytes=0-100 在头中添加Range字段，表示我要请求[0-100]这101个字节的数据。此处Range的值，可以添加多个片段，如 Range：bytes=0-100,200-300等。 服务器响应报文： HTTP/1.1 206 OK Content-Length: 801 Content-Type: application/octet-stream Content-Location: http://www.onlinedown.net/hj_index.htm Content-Range: bytes 0-100/2350 //2350:文件总大小 Last-Modified: Mon, 16 Feb 2009 16:10:12 GMT Accept-Ranges: bytes ETag: &quot;d67a4bc5190c91:512&quot; Date: Wed, 18 Feb 2009 07:55:26 GMT 响应报文中有Content-Range字段，表示响应的报文片段内容范围，已经总的数据大小。同时Range请求的正常的返回码是206，不是200。 而即使我们请求的不是Range功能请求，那么服务器的返回字段中会有Accept-Range，表示服务器支持Range功能。 Server:例：Server: Apache/2.4.1 (Unix)表示服务器的名称，是Unix下的Apache服务器 Set-Cookie：向客户端设置cookie，通过查看此头，可以清楚看到服务器向客户端发送的cookie信息。 Location服务器通过通过这个头告诉浏览器去访问那个页面，浏览器收到这个请求之后，通常会立刻访问location头所指向的页面。这个头通常配合302状态码使用。 Refresh：服务器通过该头告诉浏览器定时刷新浏览器。 转载 Boboma_dut 的CSDN 博客 ，全文地址请点击：https://blog.csdn.net/Boboma_dut/article/details/79741162?utm_source=copy","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"学习","slug":"学习","permalink":"/tags/学习/"},{"name":"HTTP","slug":"HTTP","permalink":"/tags/HTTP/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"web学习笔记——文件上传","slug":"web学习笔记——文件上传","date":"2021-01-29T00:29:22.000Z","updated":"2021-07-16T02:00:46.305Z","comments":true,"path":"2021/01/29/web学习笔记——文件上传/","link":"","permalink":"/2021/01/29/web学习笔记——文件上传/","excerpt":"","text":"文件上传漏洞总结常见工具：BurpSuite、蚁剑。 原理及利用为什么会有文件上传漏洞，字面意思文件上传的漏洞。在一些上传文件的入口，面对上传文件，若不对上传文件进行严格的验证和过滤就容易造成这漏洞的产生。即可能上传任何文件——包括病毒、脚本。 上传正常的php对服务器没有什么危害，但总有离谱的——如：PHP是编程语言，可以查看目录下的文件，查看文件中的代码，还能执行系统命令。上传恶意的PHP文件，甚至还能控制整个网站文件甚至是服务器。 或者有上传钓鱼图片的，flash的策略文件.xml的。 不过一般情况下的利用，指的应该就是“上传web脚本”并让服务器解析吧。即webshell攻击。成功的条件也是有的：能上传，能调用，能被执行，不被安全检查（想办法绕过）或格式化或者图片马被压缩（可能会导致内容改变而影响功能）。 常见绕过总结客户端校验通过javascript来校验上传文件的后缀是否合法，可以采用白名单，也可以采用黑名单的方式判断方式：在浏览加载文件，但还未点击上传按钮时便弹出对话框，内容如：只允许上传.jpg/.jpeg/.png后缀名的文件，而此时并没有发送数据包。客户端校验绕过：直接修改js代码（一些浏览器自带选项貌似有禁用js选项）或者使用抓包的方法修改请求内容绕过，可以先上传一个gif木马，通过抓包修改为 jsp/php/asp，只用这种方法来检测是肯定可以绕过的。 服务器端校验校验请求头 content-type字段，例如用PHP检测 if($_FILES[‘userfile’][‘type’] != “image/gif”){ ….}通过自己写正则匹配来判断文件幻数(文件头)内容是否符合要求，一般来说属于白名单的检测，常见的文件头（文件头标志位）如下：括号中对应的二进制代码（1）.JPEG;.JPE;.JPG，”JPGGraphicFile”（FFD8FFFE00）（2）.gif，”GIF89A”（474946383961）（3）.zip，”ZipCompressed”（504B0304）（4）.doc;.xls;.xlt;.ppt;.apr，”MSCompoundDocumentv1orLotusApproachAPRfile”（D0CF11E0A1B11AE1）还有其他的文件头可自行资料查找。 服务端绕过校验请求头content-type字段绕过 通过抓包来修改Http头的content-type即可绕过，也肯定是可以绕过这种检测 POST /upload.php HTTP/1.1TE: deflate,gzip;q=0.3Connection: TE, closeHost: localhostUser-Agent: libwww-perl/5.803Content-Type: multipart/form-data; boundary=xYzZYContent-Length: 155–666666666666666666666666-Content-Disposition: form-data; name=”userfile”; filename=”shell.php”Content-Type: image/gif (原为 Content-Type: text/plain)&lt;?php system($_GET[‘command’]);?&gt;–6666666666666666666666666- 文件幻数(文件头)检测绕过： 在木马内容的前面插入对应的文件头内容，例如：GIF89a ，更靠谱的方法是在可上传的文件中插入木马代码，然后修改后缀 文件加载检测：一般是调用API或函数去进行文件加载测试，例如图像渲染测试，当测试结果正常的时候才允许上传 1、一次渲染（代码注入）2、二次渲染 文件加载检绕过通过例如加载文件进行图像渲染的方式来测试，这个时候就一般需要在正常的文件中插入木马代码了，例如图像，那么插入的代码一般会放在图像的注释区，因此不会影响图像正常渲染绕过这种检测，此时可以使用工具（称为插马器）来进行插入，例如edjpgcom，或者直接用copy命令来合成也可以。当然这种检测不一定能够完全绕过 后缀名黑名单校验、后缀名白名单校验：后缀名检测 后缀黑名单检测绕过：找查blacklist(黑名单列表)的漏网之鱼，例如大小写：如果检测的时候不忽略大小写，那么可以改变后缀名的大小写绕过扩展名：黑名单中如果忽略了某些能被解析的文件扩展名： jsp jspx jspf asp asa cer aspx php php php3 php4 pht php5 exe exee 后缀白名单检测绕过：白名单检测还是会比黑名单强一点，常见的绕过方法有%00截断，还有服务器的解析漏洞%00截断漏洞：如果存在这类漏洞，那么后缀名的检测都可以绕过，此时我们可以如下命名一个上传文件 test.php%00.jpg 操作系统相关绕过：上传不符合windows文件命名规则的文件名 test.asp.（windows的结尾默认不为为.会自动消掉这个点）test.asp(空格)test.php:1.jpgtest.php::$DATAshell.php::$DATA…….会被某些版本的windows系统自动去掉不符合规则符号后面的内容。 linux下后缀名大小写：linux是大小写敏感的，因此一般检测也会区分大小写，但某些解析器是不区分大小写的，例如PHP，上传php不被解析，可以试试上传pHp后缀的文件名。 竞争条件攻击：一些网站上传文件逻辑上是允许上传任意文件的，然后检查上传文件的内容是否包含webshell脚本，如果包含则删除该文件，这里存在的问题是文件上传成功之后和删除文件之间存在一个短的时间差，攻击者就可以利用这个时间差来上传漏洞攻击。攻击者先上传一个webshell脚本1.php内容如下： &lt;?php fputs(fopen(‘../shell.php’,’w’),’&lt;?php @eval($_POST[a]) ?&gt;’); ?&gt;代码内容就是生成一个新的webshell，shell.php，那么当1.php上传成功之后，我们快速访问这个文件，这时就会在服务器端当前目录下自动生成shell.php，这时就利用时间差完成了webshell的上传。 CMS、编辑器漏洞CMS漏洞： 可以针对不同CMS存在的上传漏洞进行绕过。编辑器漏洞：比如FCK，ewebeditor等，可以针对编辑器的漏洞进行绕过。参考链接：https://www.leavesongs.com/PENETRATION/UseOfFckeditor.htmlhttps://docs.google.com/document/d/1w_61xR8U7nmn4Y0CvBHpG1uFIU2ORx69QnqTxQt8Km0/edit?pli=1 WAF校验：即使用不同的WAF产品来进行过滤，通常是独立与服务程序的一段中间程序或者硬件 WAF绕过：参考链接：https://www.freebuf.com/articles/web/160175.html 解析漏洞：这类漏洞是本身服务器的中间件产生的，例如apache，nginx都被爆出过存在解析漏洞，存在解析漏洞的话，上传的安全性几乎就完全失去了，下面再详细分析。 服务器解析漏洞 IS5.x-6.x解析漏洞使用iis5.x-6.x版本的服务器，大多为windows server 2003，网站比较古老，开发语句一般为asp；该解析漏洞也只能解析asp文件，而不能解析aspx文件。 目录解析(6.0)形式：www.xxx.com/xx.asp/xx.jpg 原理: 服务器默认会把.asp，.asp目录下的文件都解析成asp文件。 文件解析形式：www.xxx.com/xx.asp;.jpg 原理：服务器默认不解析;号后面的内容，因此xx.asp;.jpg便被解析成asp文件了。 解析文件类型 IIS6.0 默认的可执行文件除了asp还包含这三种 :/test.asa/test.cer/test.cdx apache解析漏洞漏洞原理 Apache 解析文件的规则是从右到左开始判断解析,如果后缀名为不可识别文件解析,就再往左判断。比如 test.php.qwe.asd “.qwe”和”.asd” 这两种后缀是apache不可识别解析,apache就会把wooyun.php.qwe.asd解析成php。 漏洞形式 www.xxxx.xxx.com/test.php.php123其余配置问题导致漏洞 如果在 Apache 的 conf 里有这样一行配置 AddHandler php5-script .php 这时只要文件名里包含.php 即使文件名是 test2.php.jpg 也会以 php 来执行。 如果在 Apache 的 conf 里有这样一行配置 AddType application/x-httpd-php .jpg 即使扩展名是 jpg，一样能以 php 方式执行。 nginx解析漏洞漏洞原理 Nginx默认是以CGI的方式支持PHP解析的，普遍的做法是在Nginx配置文件中通过正则匹配设置 SCRIPT_FILENAME。当访问 www.xx.com/phpinfo.jpg/1.php这个URL时， $fastcgi_script_name会被设置为 “phpinfo.jpg/1.php”，然后构造成 SCRIPT_FILENAME传递给PHP CGI，但是PHP为什么会接受这样的参数，并将phpinfo.jpg作为PHP文件解析呢?这就要说到fix_pathinfo这个选项了。 如果开启了这个选项，那么就会触发在PHP中的如下逻辑： PHP会认为SCRIPTFILENAME是phpinfo.jpg，而1.php是PATHINFO，所以就会将phpinfo.jpg作为PHP文件来解析了 漏洞形式 www.xxxx.com/UploadFiles/image/1.jpg/1.phpwww.xxxx.com/UploadFiles/image/1.jpg %00.phpwww.xxxx.com/UploadFiles/image/1.jpg/ %20.php 另外一种手法：上传一个名字为test.jpg，然后访问test.jpg/.php,在这个目录下就会生成一句话木马shell.php。 IIS7.5解析漏洞 IIS7.5的漏洞与nginx的类似，都是由于php配置文件中，开启了 cgi.fix_pathinfo，而这并不是nginx或者iis7.5本身的漏洞。 参考文章 https://www.secpulse.com/archives/95987.htmlhttps://blog.csdn.net/weixin_44119101/article/details/107669831","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"学习","slug":"学习","permalink":"/tags/学习/"},{"name":"文件上传漏洞","slug":"文件上传漏洞","permalink":"/tags/文件上传漏洞/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"web学习笔记——SQL注入","slug":"web学习笔记——SQL注入","date":"2021-01-03T02:57:32.000Z","updated":"2021-07-12T07:40:24.651Z","comments":true,"path":"2021/01/03/web学习笔记——SQL注入/","link":"","permalink":"/2021/01/03/web学习笔记——SQL注入/","excerpt":"","text":"SQL产生原理​ 所谓SQL注入，就是通过把SQL命令插入到Web表单递交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。当应用程序使用输入内容来构造动态sql语句以访问数据库时，会发生sql注入攻击。如果代码使用存储过程，而这些存储过程作为包含未筛选的用户输入的字符串来传递，也会发生sql注入。 黑客通过SQL注入攻击可以拿到网站数据库的访问权限，之后他们就可以拿到网站数据库中所有的数据，恶意的黑客可以通过SQL注入功能篡改数据库中的数据甚至会把数据库中的数据毁坏掉 ​ 通过构建特殊的输入作为参数传入Web应用程序，而这些输入大都是SQL语法里的一些组合，通过执行SQL语句进而执行攻击者所要的操作，其主要原因是程序没有细致地过滤用户输入的数据，致使非法数据侵入系统。 ​ 根据相关技术原理，SQL注入可以分为平台层注入和代码层注入。前者由不安全的数据库配置或数据库平台的漏洞所致；后者主要是由于程序员对输入未进行细致地过滤，从而执行了非法的数据查询。基于此，SQL注入的产生原因通常表现在以下几方面：①不当的类型处理；②不安全的数据库配置；③不合理的查询集处理；④不当的错误处理；⑤转义字符处理不合适；⑥多个提交处理不当。 SQL注入方法理解1.数字注入 在浏览器地址栏输入：learn.me/sql/article.php?id=1，这是一个get型接口，发送这个请求相当于调用一个查询语句： $sql = &quot;SELECT * FROM article WHERE id =&quot;,$id 正常情况下，应该返回一个id=1的文章信息。那么，如果在浏览器地址栏输入：learn.me/sql/article.php?id=-1 OR 1 =1，这就是一个SQL注入攻击了，可能会返回所有文章的相关信息。为什么会这样呢？ 这是因为，id = -1永远是false，1=1永远是true，所有整个where语句永远是ture，所以where条件相当于没有加where条件，那么查询的结果相当于整张表的内容。（危） 2.字符串注入 有这样一个用户登录场景：登录界面包括用户名和密码输入框，以及提交按钮。输入用户名和密码，提交。 这是一个post请求，登录时调用接口learn.me/sql/login.html，首先连接数据库，然后后台对post请求参数中携带的用户名、密码进行参数校验，即sql的查询过程。假设正确的用户名和密码为user和pwd123，输入正确的用户名和密码、提交，相当于调用了以下的SQL语句： SELECT * FROM user WHERE username = &#39;user&#39; ADN password = &#39;pwd123&#39; ​ 由于用户名和密码都是字符串，SQL注入方法即把参数携带的数据变成mysql中注释的字符串。mysql中有2种注释的方法： （1）’#’：’#’后所有的字符串都会被当成注释来处理 用户名输入：user’#（单引号闭合user左边的单引号），密码随意输入，如：111，然后点击提交按钮。等价于SQL语句： SELECT * FROM user WHERE username = &#39;user&#39;#&#39;ADN password = &#39;111&#39; ‘#’后面都被注释掉了，相当于： SELECT * FROM user WHERE username = &#39;user&#39; （2）’– ‘ （–后面有个空格）：’– ‘后面的字符串都会被当成注释来处理 用户名输入：user’– （注意–后面有个空格，单引号闭合user左边的单引号），密码随意输入，如：111，然后点击提交按钮。等价于SQL语句： SELECT * FROM user WHERE username = &#39;user&#39;-- &#39;AND password = &#39;111&#39; SELECT * FROM user WHERE username = ‘user’– ‘AND password = ‘1111’ ‘– ‘后面都被注释掉了，相当于： SELECT * FROM user WHERE username = &#39;user&#39; 因此，以上两种情况可能输入一个错误的密码或者不输入密码就可登录用户名为’user’的账号，这是十分危险的事情。 SQL注入点判断分类 1、常见的sql注入按照参数类型可分为两种：数字型和字符型。 当发生注入点的参数为整数时，比如 ID，num，page等，这种形式的就属于数字型注入漏洞。同样，当注入点是字符串时，则称为字符型注入，字符型注入需要引号来闭合。 2、也可以根据数据库返回的结果，分为回显注入、报错注入、盲注。 回显注入：可以直接在存在注入点的当前页面中获取返回结果。 报错注入：程序将数据库的返回错误信息直接显示在页面中，虽然没有返回数据库的查询结果，但是可以构造一些报错语句从错误信息中获取想要的结果。 盲注：程序后端屏蔽了数据库的错误信息，没有直接显示结果也没有报错信息，只能通过数据库的逻辑和延时函数来判断注入的结果。根据表现形式的不同，盲注又分为based boolean和based time两种类型。 3、按照注入位置及方式不同分为：post注入，get注入，cookie注入，盲注，延时注入，搜索注入，base64注入，无论此种分类如何多，都可以归纳为以上两种形式。 判断 GET注入1、数字型：猜测SQL语句： select 字段名 from 表名 where id = 1； http://www.sql.com/xxx.php?id=1 假设ID为存在注入的参数 http://www.sql.com/xxx.php?id=1‘ 语句报错 http://www.sql.com/xxx.php?id=1 and 1=1 页面正常返回结果 http://www.sql.com/xxx.php?id=1 and 1=2 页面返回错误 1234 如果以上几个测试步骤结果全部满足，就可能存在sql注入漏洞。 数字型注入一般出现在asp，php等弱类型语言中，弱类型语言会自动推导变量类型，例如，参数id=1，PHP会自动把ID的数据类型推导为int类型，若是 id=1 and 1=1，则把ID推导为string类型。但是对于Java、c#这类强类型语言，如果把一个字符串转换为int类型，则会抛出异常，无法运行，所以数字型注入一般出现在弱类型的语言当中，强类型语言很少存在。 2、字符型：猜测SQL语句： select 字段名 from 表名 where id =‘； http://www.sql.com/xxx.php?id=1 假设ID为存在注入的参数 http://www.sql.com/xxx.php?id=1‘ 语句报错 http://www.sql.com/xxx.php?id=1&#39; and 1=1 and &#39;1&#39;=&#39;1 页面正常返回结果 http://www.sql.com/xxx.php?id=1&#39; and 1=2 and &#39;1&#39;=&#39;1 页面返回错误 1234 3、搜索型：猜测SQL语句： select 字段 from 表名 where username like ‘%k%’; http://www.sql.com/xxx.php?search=test 假设search为存在注入的参数 http://www.sql.com/xxx.php?search=test&#39; 语句报错 http://www.sql.com/xxx.php?search=test%&#39; and 1=1 and &#39;%&#39;=&#39; 页面正常返回结果 http://www.sql.com/xxx.php?search=test%&#39; and 1=2 and &#39;%&#39;=&#39; 页面返回错误 常见SQL注入过滤的绕过1-1.and/or的过滤/拦截双写使用运算符(||、&amp;&amp;)直接使用拼接=号使用异或注入 1-2.空格被过滤/拦截多层括号嵌套改用+号使用注释/**/and/or后面可以跟上偶数个!、~可以替代空格，也可以混合使用(规律又不同)，and/or前的空格可用省略%09, %0a, %0b, %0c, %0d, %a0等部分不可见字符可也代替空格（因为Windows的解析机制无法使用特殊字符代替空格，需要Linux的服务器环境才行） 1-3.括号被过滤/拦截order by 大小比较盲注（见下面的讲解） 1-4.逗号被过滤/拦截改用盲注 使用join语句代替，如union select 1,2,3 可改为 union select join(select 1) join(select 2) join(select 3) substr(data from 1 for 1)相当于substr(data,1,1)、limit 9 offset 4相当于limt 9,4 1-5.information_schema被过滤/拦截利用innodb存储引擎(需要Mysql版本在5.5.x后并且Mysql开启了innoDB引擎)，例如下： select table_name from mysql.innodb_table_stats where database_name=database(); select table_name from mysql.innodb_index_stats where database_name=database(); 接下来的四个只能用于查表名，无法查询列名，所以进一步获取数据还需无列名注入sys.schema_auto_increment_columnssys.x$schema_table_statistics_with_buffersys.schema_table_statistics_with_buffersys.x$ps_schema_table_statistics_io 那么接下来就补充一下无列名注入吧 利用join进行无列名注入（使用别名）join … using(xx) 当知道表名为users时，使用如下语句得到列名第一列：?id=-1’union all selectfrom (select from users as a join users b)c# 第二列：?id=-1’ union all selectfrom (select from users as a join users b using(id))c–+ 第三列：?id=-1’ union all selectfrom (select from users as a join users b using(id,username))c–+ 后面的列名可以此类推 1-6.单双引号被被过滤/拦截/转义 可根据sql语句，使用转移符号逃逸出一个单/双引号，例题可参考[BJDCTF 2nd]简单注入 需要逃逸单引号的情况：尝试是否存在编码问题而产生的SQL注入。不需要逃逸单引号的情况：字符串可用十六进制(hex函数)表示、也可通过进制转换函数表示成其他进制或者使用其他编码，如char()SELECT FROM Users WHERE username = CHAR(97, 100, 109, 105, 110) 还可以使用%2527主要绕过magic_quotes_gpc过滤，因为%25解码为%,结合后面的27也就是%27也就是’，所以成功绕过过滤。 1-7.数字和单个字母被过滤/拦截false或!pi()：0 true或!!pi()：1 true+true：2 floor(pi())：3 ceil(pi())：4 floor(version())：5 ceil(version())：6 ceil(pi()+pi())：7 floor(version()+pi())：8 floor(pi()*pi())：9 ceil(pi()*pi())：10 ceil(pi()*pi())+true：11 ceil(pi()+pi()+version())：12 floor(pi()*pi()+pi())：13 ceil(pi()*pi()+pi())：14 ceil(pi()*pi()+version())：15 floor(pi()*version())：16 ceil(pi()*version())：17 ceil(pi()*version())+true：18 floor((pi()+pi())*pi())：19 ceil((pi()+pi())*pi())：20 ceil(ceil(pi())*version())：21 ceil(pi()*ceil(pi()+pi()))：22 ceil((pi()+ceil(pi()))*pi())：23 ceil(pi())*ceil(version())：24 floor(pi()*(version()+pi()))：25 floor(version()*version())：26 ceil(version()*version())：27 ceil(pi()*pi()*pi()-pi())：28 floor(pi()*pi()*floor(pi()))：29 使用conv([0-9],10,36)可以表示0~9的数字，conv([10~35],10,36)可以表示a~z单个字母，conv([35+],10,36)可自行按照三十六进制转换 1-8.其他系统关键字被过滤/拦截双写绕过关键字过滤使用同义函数/语句代替，如if函数可用如下语句代替。 case when condition then 1 else 0 end 1-9.等号被过滤使用in或like关键字绕过 1-10.过滤sleep() BENCHMARK(count,expr)BENCHMARK()函数重复countTimes次执行表达式expr，它可以用于计时MySQL处理表达式有多快。结果值总是0。 笛卡尔积select if(1=1,(SELECT count(*) FROM information_schema.columns A, information_schema.columns B),0); GET_LOCK在一个session中可以先锁定一个变量例如：select get_lock(‘smi1e’,1)然后通过另一个session 再次执行get_lock函数 select get_lock(‘smi1e’,5),此时会产生5 秒的延迟，其效果类似于sleep(5)。但是利用场景是有条件限制的：需要提供长连接。在Apache+PHP搭建的环境中需要使用 mysql_pconnect函数来连接数据库。 RLIKE/REGEXP通过rpad或repeat构造长字符串，加以计算量大的pattern，通过repeat的参数可以控制延时长短。select rpad(‘a’,4999999,’a’) RLIKE concat(repeat(‘(a.*)+’,30),’b’)","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"SQL注入漏洞","slug":"SQL注入漏洞","permalink":"/tags/SQL注入漏洞/"},{"name":"学习","slug":"学习","permalink":"/tags/学习/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"随手写写","slug":"随手写写","date":"2020-12-31T07:10:02.000Z","updated":"2021-07-16T01:34:22.603Z","comments":true,"path":"2020/12/31/随手写写/","link":"","permalink":"/2020/12/31/随手写写/","excerpt":"","text":"发牢骚!刚刚建好不久的空网站，空空的 写点啥呢 自己的博客搭好了QWQ，主要还是当笔记本/日记本用吧，是懒狗新人的小本本（bushi） 希望在未来很多年，这个博客能跟着我走下去，见证我的进步，见证我的蜕变，我会好好对它的，等着，我迟早把网站大变样，靠自己双手，写一个自己的网页。 QWQ加油！","categories":[{"name":"随想","slug":"随想","permalink":"/categories/随想/"}],"tags":[{"name":"随想","slug":"随想","permalink":"/tags/随想/"},{"name":"悦读","slug":"悦读","permalink":"/tags/悦读/"}],"keywords":[{"name":"随想","slug":"随想","permalink":"/categories/随想/"}]}]}